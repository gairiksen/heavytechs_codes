var CHARSET_RE = /(?:^|;)\s*charset=(.+)(?:;|$)/i;

var META_CHARSET_RE = /charset ?= ?['"]?([^ ;"']*)['"]?/i;

var DEFAULT_CHARSET = "iso-8859-1";

var CHARSET_BOM_LIST = [ {
    charset: "utf-8",
    bom: [ 239, 187, 191 ]
}, {
    charset: "utf-16le",
    bom: [ 255, 254 ]
}, {
    charset: "utf-16be",
    bom: [ 254, 255 ]
} ];

var PRIORITY_LIST = {
    BOM: 3,
    CONTENT_TYPE: 2,
    URL: 1,
    META: 1,
    DEFAULT: 0
};

var CHARSETS = [ "iso-8859-1", "iso-8859-2", "iso-8859-3", "iso-8859-4", "iso-8859-5", "iso-8859-6", "iso-8859-7", "iso-8859-8", "iso-8859-9", "iso-8859-10", "iso-8859-11", "iso-8859-12", "iso-8859-13", "iso-8859-14", "iso-8859-15", "iso-8859-16", "windows-1250", "windows-1251", "windows-1252", "windows-1253", "windows-1254", "windows-1255", "windows-1256", "windows-1257", "windows-1258", "windows-874", "windows-866", "koi8-r", "koi8-u", "utf-8", "utf-16", "utf-16le", "utf-16be", "utf-32", "shift-jis", "x-euc", "big5", "euc-kr" ];

function getNormalizedCharsetMapKey(charset) {
    return charset.replace(/-/g, "").toLowerCase();
}

var normalizedCharsetsMap = CHARSETS.reduce(function(charsetMap, charset) {
    charsetMap[getNormalizedCharsetMapKey(charset)] = charset;
    return charsetMap;
}, {});

function normalizeCharset(charset) {
    var key = charset && getNormalizedCharsetMapKey(charset);
    return normalizedCharsetsMap[key] || null;
}

function bufferStartsWithBOM(resBuf, bom) {
    if (resBuf.length < bom.length) return false;
    for (var i = 0; i < bom.length; i++) {
        if (resBuf[i] !== bom[i]) return false;
    }
    return true;
}

function Charset() {
    this.charset = DEFAULT_CHARSET;
    this.priority = PRIORITY_LIST.DEFAULT;
}

Charset.prototype.set = function(charset, priority) {
    if (charset && this.charset !== charset && this.priority <= priority) {
        this.charset = charset;
        this.priority = priority;
        return true;
    }
    return false;
};

Charset.prototype.get = function() {
    return this.charset;
};

Charset.prototype.isFromBOM = function() {
    return this.priority === PRIORITY_LIST.BOM;
};

Charset.prototype.fromBOM = function(resBuf) {
    for (var i = 0; i < CHARSET_BOM_LIST.length; i++) {
        if (bufferStartsWithBOM(resBuf, CHARSET_BOM_LIST[i].bom)) return this.set(CHARSET_BOM_LIST[i].charset, PRIORITY_LIST.BOM);
    }
    return false;
};

Charset.prototype.fromContentType = function(contentTypeHeader) {
    if (this.priority <= PRIORITY_LIST.CONTENT_TYPE) {
        var charsetMatch = contentTypeHeader && contentTypeHeader.match(CHARSET_RE);
        var charset = charsetMatch && charsetMatch[1];
        return this.set(normalizeCharset(charset), PRIORITY_LIST.CONTENT_TYPE);
    }
    return false;
};

Charset.prototype.fromUrl = function(charsetFromUrl) {
    if (charsetFromUrl && this.priority <= PRIORITY_LIST.URL) return this.set(normalizeCharset(charsetFromUrl), PRIORITY_LIST.URL);
    return false;
};

Charset.prototype.fromMeta = function(metas) {
    if (this.priority < PRIORITY_LIST.META && metas.length) {
        var needPragma = null;
        var charsetStr = null;
        metas.forEach(function(attrs) {
            var shouldParseFromContentAttr = needPragma !== false && attrs.content && attrs.httpEquiv && attrs.httpEquiv.toLowerCase() === "content-type";
            if (shouldParseFromContentAttr) {
                var charsetMatch = attrs.content.match(META_CHARSET_RE);
                if (charsetMatch) {
                    needPragma = true;
                    charsetStr = charsetMatch[1];
                }
            }
            if (attrs.charset) {
                needPragma = false;
                charsetStr = attrs.charset;
            }
        });
        return this.set(normalizeCharset(charsetStr), PRIORITY_LIST.META);
    }
    return false;
};

module.exports = Charset;