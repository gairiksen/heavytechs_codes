(function() {
    var JSParsingTools = {};
    var acornExports = function() {
        var define, module, exports;
        return function e(t, n, r) {
            function s(o, u) {
                if (!n[o]) {
                    if (!t[o]) {
                        var a = typeof require == "function" && require;
                        if (!u && a) return a(o, !0);
                        if (i) return i(o, !0);
                        var f = new Error("Cannot find module '" + o + "'");
                        throw f.code = "MODULE_NOT_FOUND", f;
                    }
                    var l = n[o] = {
                        exports: {}
                    };
                    t[o][0].call(l.exports, function(e) {
                        var n = t[o][1][e];
                        return s(n ? n : e);
                    }, l, l.exports, e, t, n, r);
                }
                return n[o].exports;
            }
            var i = typeof require == "function" && require;
            for (var o = 0; o < r.length; o++) s(r[o]);
            return s;
        }({
            1: [ function(_dereq_, module, exports) {
                "use strict";
                var _tokentype = _dereq_("./tokentype");
                var _state = _dereq_("./state");
                var _parseutil = _dereq_("./parseutil");
                var pp = _state.Parser.prototype;
                pp.checkPropClash = function(prop, propHash) {
                    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
                    var key = prop.key;
                    var name = undefined;
                    switch (key.type) {
                      case "Identifier":
                        name = key.name;
                        break;

                      case "Literal":
                        name = String(key.value);
                        break;

                      default:
                        return;
                    }
                    var kind = prop.kind;
                    if (this.options.ecmaVersion >= 6) {
                        if (name === "__proto__" && kind === "init") {
                            if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
                            propHash.proto = true;
                        }
                        return;
                    }
                    name = "$" + name;
                    var other = propHash[name];
                    if (other) {
                        var isGetSet = kind !== "init";
                        if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raiseRecoverable(key.start, "Redefinition of property");
                    } else {
                        other = propHash[name] = {
                            init: false,
                            get: false,
                            set: false
                        };
                    }
                    other[kind] = true;
                };
                pp.parseExpression = function(noIn, refDestructuringErrors) {
                    var startPos = this.start, startLoc = this.startLoc;
                    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
                    if (this.type === _tokentype.types.comma) {
                        var node = this.startNodeAt(startPos, startLoc);
                        node.expressions = [ expr ];
                        while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
                        return this.finishNode(node, "SequenceExpression");
                    }
                    return expr;
                };
                pp.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
                    if (this.inGenerator && this.isContextual("yield")) return this.parseYield();
                    var ownDestructuringErrors = false;
                    if (!refDestructuringErrors) {
                        refDestructuringErrors = new _parseutil.DestructuringErrors();
                        ownDestructuringErrors = true;
                    }
                    var startPos = this.start, startLoc = this.startLoc;
                    if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
                    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
                    if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
                    if (this.type.isAssign) {
                        this.checkPatternErrors(refDestructuringErrors, true);
                        if (!ownDestructuringErrors) _parseutil.DestructuringErrors.call(refDestructuringErrors);
                        var node = this.startNodeAt(startPos, startLoc);
                        node.operator = this.value;
                        node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
                        refDestructuringErrors.shorthandAssign = 0;
                        this.checkLVal(left);
                        this.next();
                        node.right = this.parseMaybeAssign(noIn);
                        return this.finishNode(node, "AssignmentExpression");
                    } else {
                        if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
                    }
                    return left;
                };
                pp.parseMaybeConditional = function(noIn, refDestructuringErrors) {
                    var startPos = this.start, startLoc = this.startLoc;
                    var expr = this.parseExprOps(noIn, refDestructuringErrors);
                    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
                    if (this.eat(_tokentype.types.question)) {
                        var node = this.startNodeAt(startPos, startLoc);
                        node.test = expr;
                        node.consequent = this.parseMaybeAssign();
                        this.expect(_tokentype.types.colon);
                        node.alternate = this.parseMaybeAssign(noIn);
                        return this.finishNode(node, "ConditionalExpression");
                    }
                    return expr;
                };
                pp.parseExprOps = function(noIn, refDestructuringErrors) {
                    var startPos = this.start, startLoc = this.startLoc;
                    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
                    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
                    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
                };
                pp.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
                    var prec = this.type.binop;
                    if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
                        if (prec > minPrec) {
                            var logical = this.type === _tokentype.types.logicalOR || this.type === _tokentype.types.logicalAND;
                            var op = this.value;
                            this.next();
                            var startPos = this.start, startLoc = this.startLoc;
                            var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
                            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
                            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
                        }
                    }
                    return left;
                };
                pp.buildBinary = function(startPos, startLoc, left, right, op, logical) {
                    var node = this.startNodeAt(startPos, startLoc);
                    node.left = left;
                    node.operator = op;
                    node.right = right;
                    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
                };
                pp.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
                    var startPos = this.start, startLoc = this.startLoc, expr = undefined;
                    if (this.type.prefix) {
                        var node = this.startNode(), update = this.type === _tokentype.types.incDec;
                        node.operator = this.value;
                        node.prefix = true;
                        this.next();
                        node.argument = this.parseMaybeUnary(null, true);
                        this.checkExpressionErrors(refDestructuringErrors, true);
                        if (update) this.checkLVal(node.argument); else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); else sawUnary = true;
                        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
                    } else {
                        expr = this.parseExprSubscripts(refDestructuringErrors);
                        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
                        while (this.type.postfix && !this.canInsertSemicolon()) {
                            var node = this.startNodeAt(startPos, startLoc);
                            node.operator = this.value;
                            node.prefix = false;
                            node.argument = expr;
                            this.checkLVal(expr);
                            this.next();
                            expr = this.finishNode(node, "UpdateExpression");
                        }
                    }
                    if (!sawUnary && this.eat(_tokentype.types.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false); else return expr;
                };
                pp.parseExprSubscripts = function(refDestructuringErrors) {
                    var startPos = this.start, startLoc = this.startLoc;
                    var expr = this.parseExprAtom(refDestructuringErrors);
                    var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
                    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
                    return this.parseSubscripts(expr, startPos, startLoc);
                };
                pp.parseSubscripts = function(base, startPos, startLoc, noCalls) {
                    for (;;) {
                        if (this.eat(_tokentype.types.dot)) {
                            var node = this.startNodeAt(startPos, startLoc);
                            node.object = base;
                            node.property = this.parseIdent(true);
                            node.computed = false;
                            base = this.finishNode(node, "MemberExpression");
                        } else if (this.eat(_tokentype.types.bracketL)) {
                            var node = this.startNodeAt(startPos, startLoc);
                            node.object = base;
                            node.property = this.parseExpression();
                            node.computed = true;
                            this.expect(_tokentype.types.bracketR);
                            base = this.finishNode(node, "MemberExpression");
                        } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
                            var node = this.startNodeAt(startPos, startLoc);
                            node.callee = base;
                            node.arguments = this.parseExprList(_tokentype.types.parenR, false);
                            base = this.finishNode(node, "CallExpression");
                        } else if (this.type === _tokentype.types.backQuote) {
                            var node = this.startNodeAt(startPos, startLoc);
                            node.tag = base;
                            node.quasi = this.parseTemplate();
                            base = this.finishNode(node, "TaggedTemplateExpression");
                        } else {
                            return base;
                        }
                    }
                };
                pp.parseExprAtom = function(refDestructuringErrors) {
                    var node = undefined, canBeArrow = this.potentialArrowAt == this.start;
                    switch (this.type) {
                      case _tokentype.types._super:
                        if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");

                      case _tokentype.types._this:
                        var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
                        node = this.startNode();
                        this.next();
                        return this.finishNode(node, type);

                      case _tokentype.types.name:
                        var startPos = this.start, startLoc = this.startLoc;
                        var id = this.parseIdent(this.type !== _tokentype.types.name);
                        if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [ id ]);
                        return id;

                      case _tokentype.types.regexp:
                        var value = this.value;
                        node = this.parseLiteral(value.value);
                        node.regex = {
                            pattern: value.pattern,
                            flags: value.flags
                        };
                        return node;

                      case _tokentype.types.num:
                      case _tokentype.types.string:
                        return this.parseLiteral(this.value);

                      case _tokentype.types._null:
                      case _tokentype.types._true:
                      case _tokentype.types._false:
                        node = this.startNode();
                        node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
                        node.raw = this.type.keyword;
                        this.next();
                        return this.finishNode(node, "Literal");

                      case _tokentype.types.parenL:
                        return this.parseParenAndDistinguishExpression(canBeArrow);

                      case _tokentype.types.bracketL:
                        node = this.startNode();
                        this.next();
                        node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
                        return this.finishNode(node, "ArrayExpression");

                      case _tokentype.types.braceL:
                        return this.parseObj(false, refDestructuringErrors);

                      case _tokentype.types._function:
                        node = this.startNode();
                        this.next();
                        return this.parseFunction(node, false);

                      case _tokentype.types._class:
                        return this.parseClass(this.startNode(), false);

                      case _tokentype.types._new:
                        return this.parseNew();

                      case _tokentype.types.backQuote:
                        return this.parseTemplate();

                      default:
                        this.unexpected();
                    }
                };
                pp.parseLiteral = function(value) {
                    var node = this.startNode();
                    node.value = value;
                    node.raw = this.input.slice(this.start, this.end);
                    this.next();
                    return this.finishNode(node, "Literal");
                };
                pp.parseParenExpression = function() {
                    this.expect(_tokentype.types.parenL);
                    var val = this.parseExpression();
                    this.expect(_tokentype.types.parenR);
                    return val;
                };
                pp.parseParenAndDistinguishExpression = function(canBeArrow) {
                    var startPos = this.start, startLoc = this.startLoc, val = undefined;
                    if (this.options.ecmaVersion >= 6) {
                        this.next();
                        var innerStartPos = this.start, innerStartLoc = this.startLoc;
                        var exprList = [], first = true;
                        var refDestructuringErrors = new _parseutil.DestructuringErrors(), spreadStart = undefined, innerParenStart = undefined;
                        while (this.type !== _tokentype.types.parenR) {
                            first ? first = false : this.expect(_tokentype.types.comma);
                            if (this.type === _tokentype.types.ellipsis) {
                                spreadStart = this.start;
                                exprList.push(this.parseParenItem(this.parseRest()));
                                break;
                            } else {
                                if (this.type === _tokentype.types.parenL && !innerParenStart) {
                                    innerParenStart = this.start;
                                }
                                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
                            }
                        }
                        var innerEndPos = this.start, innerEndLoc = this.startLoc;
                        this.expect(_tokentype.types.parenR);
                        if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
                            this.checkPatternErrors(refDestructuringErrors, true);
                            if (innerParenStart) this.unexpected(innerParenStart);
                            return this.parseParenArrowList(startPos, startLoc, exprList);
                        }
                        if (!exprList.length) this.unexpected(this.lastTokStart);
                        if (spreadStart) this.unexpected(spreadStart);
                        this.checkExpressionErrors(refDestructuringErrors, true);
                        if (exprList.length > 1) {
                            val = this.startNodeAt(innerStartPos, innerStartLoc);
                            val.expressions = exprList;
                            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
                        } else {
                            val = exprList[0];
                        }
                    } else {
                        val = this.parseParenExpression();
                    }
                    if (this.options.preserveParens) {
                        var par = this.startNodeAt(startPos, startLoc);
                        par.expression = val;
                        return this.finishNode(par, "ParenthesizedExpression");
                    } else {
                        return val;
                    }
                };
                pp.parseParenItem = function(item) {
                    return item;
                };
                pp.parseParenArrowList = function(startPos, startLoc, exprList) {
                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
                };
                var empty = [];
                pp.parseNew = function() {
                    var node = this.startNode();
                    var meta = this.parseIdent(true);
                    if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
                        node.meta = meta;
                        node.property = this.parseIdent(true);
                        if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
                        if (!this.inFunction) this.raiseRecoverable(node.start, "new.target can only be used in functions");
                        return this.finishNode(node, "MetaProperty");
                    }
                    var startPos = this.start, startLoc = this.startLoc;
                    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
                    if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false); else node.arguments = empty;
                    return this.finishNode(node, "NewExpression");
                };
                pp.parseTemplateElement = function() {
                    var elem = this.startNode();
                    elem.value = {
                        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
                        cooked: this.value
                    };
                    this.next();
                    elem.tail = this.type === _tokentype.types.backQuote;
                    return this.finishNode(elem, "TemplateElement");
                };
                pp.parseTemplate = function() {
                    var node = this.startNode();
                    this.next();
                    node.expressions = [];
                    var curElt = this.parseTemplateElement();
                    node.quasis = [ curElt ];
                    while (!curElt.tail) {
                        this.expect(_tokentype.types.dollarBraceL);
                        node.expressions.push(this.parseExpression());
                        this.expect(_tokentype.types.braceR);
                        node.quasis.push(curElt = this.parseTemplateElement());
                    }
                    this.next();
                    return this.finishNode(node, "TemplateLiteral");
                };
                pp.parseObj = function(isPattern, refDestructuringErrors) {
                    var node = this.startNode(), first = true, propHash = {};
                    node.properties = [];
                    this.next();
                    while (!this.eat(_tokentype.types.braceR)) {
                        if (!first) {
                            this.expect(_tokentype.types.comma);
                            if (this.afterTrailingComma(_tokentype.types.braceR)) break;
                        } else first = false;
                        var prop = this.startNode(), isGenerator = undefined, startPos = undefined, startLoc = undefined;
                        if (this.options.ecmaVersion >= 6) {
                            prop.method = false;
                            prop.shorthand = false;
                            if (isPattern || refDestructuringErrors) {
                                startPos = this.start;
                                startLoc = this.startLoc;
                            }
                            if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
                        }
                        this.parsePropertyName(prop);
                        this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
                        this.checkPropClash(prop, propHash);
                        node.properties.push(this.finishNode(prop, "Property"));
                    }
                    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
                };
                pp.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
                    if (this.eat(_tokentype.types.colon)) {
                        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
                        prop.kind = "init";
                    } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
                        if (isPattern) this.unexpected();
                        prop.kind = "init";
                        prop.method = true;
                        prop.value = this.parseMethod(isGenerator);
                    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR) {
                        if (isGenerator || isPattern) this.unexpected();
                        prop.kind = prop.key.name;
                        this.parsePropertyName(prop);
                        prop.value = this.parseMethod(false);
                        var paramCount = prop.kind === "get" ? 0 : 1;
                        if (prop.value.params.length !== paramCount) {
                            var start = prop.value.start;
                            if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params"); else this.raiseRecoverable(start, "setter should have exactly one param");
                        }
                        if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
                    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
                        if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == "yield") this.raiseRecoverable(prop.key.start, "'" + prop.key.name + "' can not be used as shorthand property");
                        prop.kind = "init";
                        if (isPattern) {
                            prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
                        } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
                            if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
                            prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
                        } else {
                            prop.value = prop.key;
                        }
                        prop.shorthand = true;
                    } else this.unexpected();
                };
                pp.parsePropertyName = function(prop) {
                    if (this.options.ecmaVersion >= 6) {
                        if (this.eat(_tokentype.types.bracketL)) {
                            prop.computed = true;
                            prop.key = this.parseMaybeAssign();
                            this.expect(_tokentype.types.bracketR);
                            return prop.key;
                        } else {
                            prop.computed = false;
                        }
                    }
                    return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
                };
                pp.initFunction = function(node) {
                    node.id = null;
                    if (this.options.ecmaVersion >= 6) {
                        node.generator = false;
                        node.expression = false;
                    }
                };
                pp.parseMethod = function(isGenerator) {
                    var node = this.startNode(), oldInGen = this.inGenerator;
                    this.inGenerator = isGenerator;
                    this.initFunction(node);
                    this.expect(_tokentype.types.parenL);
                    node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
                    if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
                    this.parseFunctionBody(node, false);
                    this.inGenerator = oldInGen;
                    return this.finishNode(node, "FunctionExpression");
                };
                pp.parseArrowExpression = function(node, params) {
                    var oldInGen = this.inGenerator;
                    this.inGenerator = false;
                    this.initFunction(node);
                    node.params = this.toAssignableList(params, true);
                    this.parseFunctionBody(node, true);
                    this.inGenerator = oldInGen;
                    return this.finishNode(node, "ArrowFunctionExpression");
                };
                pp.parseFunctionBody = function(node, isArrowFunction) {
                    var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;
                    if (isExpression) {
                        node.body = this.parseMaybeAssign();
                        node.expression = true;
                    } else {
                        var oldInFunc = this.inFunction, oldLabels = this.labels;
                        this.inFunction = true;
                        this.labels = [];
                        node.body = this.parseBlock(true);
                        node.expression = false;
                        this.inFunction = oldInFunc;
                        this.labels = oldLabels;
                    }
                    if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
                        var oldStrict = this.strict;
                        this.strict = true;
                        if (node.id) this.checkLVal(node.id, true);
                        this.checkParams(node);
                        this.strict = oldStrict;
                    } else if (isArrowFunction) {
                        this.checkParams(node);
                    }
                };
                pp.checkParams = function(node) {
                    var nameHash = {};
                    for (var i = 0; i < node.params.length; i++) {
                        this.checkLVal(node.params[i], true, nameHash);
                    }
                };
                pp.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
                    var elts = [], first = true;
                    while (!this.eat(close)) {
                        if (!first) {
                            this.expect(_tokentype.types.comma);
                            if (allowTrailingComma && this.afterTrailingComma(close)) break;
                        } else first = false;
                        var elt = undefined;
                        if (allowEmpty && this.type === _tokentype.types.comma) elt = null; else if (this.type === _tokentype.types.ellipsis) {
                            elt = this.parseSpread(refDestructuringErrors);
                            if (this.type === _tokentype.types.comma && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
                                refDestructuringErrors.trailingComma = this.lastTokStart;
                            }
                        } else elt = this.parseMaybeAssign(false, refDestructuringErrors);
                        elts.push(elt);
                    }
                    return elts;
                };
                pp.parseIdent = function(liberal) {
                    var node = this.startNode();
                    if (liberal && this.options.allowReserved == "never") liberal = false;
                    if (this.type === _tokentype.types.name) {
                        if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved");
                        if (!liberal && this.inGenerator && this.value === "yield") this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator");
                        node.name = this.value;
                    } else if (liberal && this.type.keyword) {
                        node.name = this.type.keyword;
                    } else {
                        this.unexpected();
                    }
                    this.next();
                    return this.finishNode(node, "Identifier");
                };
                pp.parseYield = function() {
                    var node = this.startNode();
                    this.next();
                    if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
                        node.delegate = false;
                        node.argument = null;
                    } else {
                        node.delegate = this.eat(_tokentype.types.star);
                        node.argument = this.parseMaybeAssign();
                    }
                    return this.finishNode(node, "YieldExpression");
                };
            }, {
                "./parseutil": 9,
                "./state": 10,
                "./tokentype": 14
            } ],
            2: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                exports.isIdentifierStart = isIdentifierStart;
                exports.isIdentifierChar = isIdentifierChar;
                var reservedWords = {
                    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
                    5: "class enum extends super const export import",
                    6: "enum",
                    7: "enum",
                    strict: "implements interface let package private protected public static yield",
                    strictBind: "eval arguments"
                };
                exports.reservedWords = reservedWords;
                var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
                var keywords = {
                    5: ecma5AndLessKeywords,
                    6: ecma5AndLessKeywords + " const class extends export import super"
                };
                exports.keywords = keywords;
                var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢴऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞭꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
                var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
                var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
                var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
                nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
                var astralIdentifierStartCodes = [ 0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 287, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 1288, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541 ];
                var astralIdentifierCodes = [ 509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 168, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 3617, 6, 792618, 239 ];
                function isInAstralSet(code, set) {
                    var pos = 65536;
                    for (var i = 0; i < set.length; i += 2) {
                        pos += set[i];
                        if (pos > code) return false;
                        pos += set[i + 1];
                        if (pos >= code) return true;
                    }
                }
                function isIdentifierStart(code, astral) {
                    if (code < 65) return code === 36;
                    if (code < 91) return true;
                    if (code < 97) return code === 95;
                    if (code < 123) return true;
                    if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
                    if (astral === false) return false;
                    return isInAstralSet(code, astralIdentifierStartCodes);
                }
                function isIdentifierChar(code, astral) {
                    if (code < 48) return code === 36;
                    if (code < 58) return true;
                    if (code < 65) return false;
                    if (code < 91) return true;
                    if (code < 97) return code === 95;
                    if (code < 123) return true;
                    if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
                    if (astral === false) return false;
                    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
                }
            }, {} ],
            3: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                exports.parse = parse;
                exports.parseExpressionAt = parseExpressionAt;
                exports.tokenizer = tokenizer;
                var _state = _dereq_("./state");
                _dereq_("./parseutil");
                _dereq_("./statement");
                _dereq_("./lval");
                _dereq_("./expression");
                _dereq_("./location");
                exports.Parser = _state.Parser;
                exports.plugins = _state.plugins;
                var _options = _dereq_("./options");
                exports.defaultOptions = _options.defaultOptions;
                var _locutil = _dereq_("./locutil");
                exports.Position = _locutil.Position;
                exports.SourceLocation = _locutil.SourceLocation;
                exports.getLineInfo = _locutil.getLineInfo;
                var _node = _dereq_("./node");
                exports.Node = _node.Node;
                var _tokentype = _dereq_("./tokentype");
                exports.TokenType = _tokentype.TokenType;
                exports.tokTypes = _tokentype.types;
                var _tokencontext = _dereq_("./tokencontext");
                exports.TokContext = _tokencontext.TokContext;
                exports.tokContexts = _tokencontext.types;
                var _identifier = _dereq_("./identifier");
                exports.isIdentifierChar = _identifier.isIdentifierChar;
                exports.isIdentifierStart = _identifier.isIdentifierStart;
                var _tokenize = _dereq_("./tokenize");
                exports.Token = _tokenize.Token;
                var _whitespace = _dereq_("./whitespace");
                exports.isNewLine = _whitespace.isNewLine;
                exports.lineBreak = _whitespace.lineBreak;
                exports.lineBreakG = _whitespace.lineBreakG;
                var version = "3.1.0";
                exports.version = version;
                function parse(input, options) {
                    return new _state.Parser(options, input).parse();
                }
                function parseExpressionAt(input, pos, options) {
                    var p = new _state.Parser(options, input, pos);
                    p.nextToken();
                    return p.parseExpression();
                }
                function tokenizer(input, options) {
                    return new _state.Parser(options, input);
                }
            }, {
                "./expression": 1,
                "./identifier": 2,
                "./location": 4,
                "./locutil": 5,
                "./lval": 6,
                "./node": 7,
                "./options": 8,
                "./parseutil": 9,
                "./state": 10,
                "./statement": 11,
                "./tokencontext": 12,
                "./tokenize": 13,
                "./tokentype": 14,
                "./whitespace": 16
            } ],
            4: [ function(_dereq_, module, exports) {
                "use strict";
                var _state = _dereq_("./state");
                var _locutil = _dereq_("./locutil");
                var pp = _state.Parser.prototype;
                pp.raise = function(pos, message) {
                    var loc = _locutil.getLineInfo(this.input, pos);
                    message += " (" + loc.line + ":" + loc.column + ")";
                    var err = new SyntaxError(message);
                    err.pos = pos;
                    err.loc = loc;
                    err.raisedAt = this.pos;
                    throw err;
                };
                pp.raiseRecoverable = pp.raise;
                pp.curPosition = function() {
                    if (this.options.locations) {
                        return new _locutil.Position(this.curLine, this.pos - this.lineStart);
                    }
                };
            }, {
                "./locutil": 5,
                "./state": 10
            } ],
            5: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                exports.getLineInfo = getLineInfo;
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _whitespace = _dereq_("./whitespace");
                var Position = function() {
                    function Position(line, col) {
                        _classCallCheck(this, Position);
                        this.line = line;
                        this.column = col;
                    }
                    Position.prototype.offset = function offset(n) {
                        return new Position(this.line, this.column + n);
                    };
                    return Position;
                }();
                exports.Position = Position;
                var SourceLocation = function SourceLocation(p, start, end) {
                    _classCallCheck(this, SourceLocation);
                    this.start = start;
                    this.end = end;
                    if (p.sourceFile !== null) this.source = p.sourceFile;
                };
                exports.SourceLocation = SourceLocation;
                function getLineInfo(input, offset) {
                    for (var line = 1, cur = 0; ;) {
                        _whitespace.lineBreakG.lastIndex = cur;
                        var match = _whitespace.lineBreakG.exec(input);
                        if (match && match.index < offset) {
                            ++line;
                            cur = match.index + match[0].length;
                        } else {
                            return new Position(line, offset - cur);
                        }
                    }
                }
            }, {
                "./whitespace": 16
            } ],
            6: [ function(_dereq_, module, exports) {
                "use strict";
                var _tokentype = _dereq_("./tokentype");
                var _state = _dereq_("./state");
                var _util = _dereq_("./util");
                var pp = _state.Parser.prototype;
                pp.toAssignable = function(node, isBinding) {
                    if (this.options.ecmaVersion >= 6 && node) {
                        switch (node.type) {
                          case "Identifier":
                          case "ObjectPattern":
                          case "ArrayPattern":
                            break;

                          case "ObjectExpression":
                            node.type = "ObjectPattern";
                            for (var i = 0; i < node.properties.length; i++) {
                                var prop = node.properties[i];
                                if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
                                this.toAssignable(prop.value, isBinding);
                            }
                            break;

                          case "ArrayExpression":
                            node.type = "ArrayPattern";
                            this.toAssignableList(node.elements, isBinding);
                            break;

                          case "AssignmentExpression":
                            if (node.operator === "=") {
                                node.type = "AssignmentPattern";
                                delete node.operator;
                            } else {
                                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
                                break;
                            }

                          case "AssignmentPattern":
                            if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
                            break;

                          case "ParenthesizedExpression":
                            node.expression = this.toAssignable(node.expression, isBinding);
                            break;

                          case "MemberExpression":
                            if (!isBinding) break;

                          default:
                            this.raise(node.start, "Assigning to rvalue");
                        }
                    }
                    return node;
                };
                pp.toAssignableList = function(exprList, isBinding) {
                    var end = exprList.length;
                    if (end) {
                        var last = exprList[end - 1];
                        if (last && last.type == "RestElement") {
                            --end;
                        } else if (last && last.type == "SpreadElement") {
                            last.type = "RestElement";
                            var arg = last.argument;
                            this.toAssignable(arg, isBinding);
                            if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
                            --end;
                        }
                        if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
                    }
                    for (var i = 0; i < end; i++) {
                        var elt = exprList[i];
                        if (elt) this.toAssignable(elt, isBinding);
                    }
                    return exprList;
                };
                pp.parseSpread = function(refDestructuringErrors) {
                    var node = this.startNode();
                    this.next();
                    node.argument = this.parseMaybeAssign(refDestructuringErrors);
                    return this.finishNode(node, "SpreadElement");
                };
                pp.parseRest = function(allowNonIdent) {
                    var node = this.startNode();
                    this.next();
                    if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected(); else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();
                    return this.finishNode(node, "RestElement");
                };
                pp.parseBindingAtom = function() {
                    if (this.options.ecmaVersion < 6) return this.parseIdent();
                    switch (this.type) {
                      case _tokentype.types.name:
                        return this.parseIdent();

                      case _tokentype.types.bracketL:
                        var node = this.startNode();
                        this.next();
                        node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
                        return this.finishNode(node, "ArrayPattern");

                      case _tokentype.types.braceL:
                        return this.parseObj(true);

                      default:
                        this.unexpected();
                    }
                };
                pp.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {
                    var elts = [], first = true;
                    while (!this.eat(close)) {
                        if (first) first = false; else this.expect(_tokentype.types.comma);
                        if (allowEmpty && this.type === _tokentype.types.comma) {
                            elts.push(null);
                        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
                            break;
                        } else if (this.type === _tokentype.types.ellipsis) {
                            var rest = this.parseRest(allowNonIdent);
                            this.parseBindingListItem(rest);
                            elts.push(rest);
                            if (this.type === _tokentype.types.comma) this.raise(this.start, "Comma is not permitted after the rest element");
                            this.expect(close);
                            break;
                        } else {
                            var elem = this.parseMaybeDefault(this.start, this.startLoc);
                            this.parseBindingListItem(elem);
                            elts.push(elem);
                        }
                    }
                    return elts;
                };
                pp.parseBindingListItem = function(param) {
                    return param;
                };
                pp.parseMaybeDefault = function(startPos, startLoc, left) {
                    left = left || this.parseBindingAtom();
                    if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
                    var node = this.startNodeAt(startPos, startLoc);
                    node.left = left;
                    node.right = this.parseMaybeAssign();
                    return this.finishNode(node, "AssignmentPattern");
                };
                pp.checkLVal = function(expr, isBinding, checkClashes) {
                    switch (expr.type) {
                      case "Identifier":
                        if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
                        if (checkClashes) {
                            if (_util.has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
                            checkClashes[expr.name] = true;
                        }
                        break;

                      case "MemberExpression":
                        if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
                        break;

                      case "ObjectPattern":
                        for (var i = 0; i < expr.properties.length; i++) {
                            this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
                        }
                        break;

                      case "ArrayPattern":
                        for (var i = 0; i < expr.elements.length; i++) {
                            var elem = expr.elements[i];
                            if (elem) this.checkLVal(elem, isBinding, checkClashes);
                        }
                        break;

                      case "AssignmentPattern":
                        this.checkLVal(expr.left, isBinding, checkClashes);
                        break;

                      case "RestElement":
                        this.checkLVal(expr.argument, isBinding, checkClashes);
                        break;

                      case "ParenthesizedExpression":
                        this.checkLVal(expr.expression, isBinding, checkClashes);
                        break;

                      default:
                        this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
                    }
                };
            }, {
                "./state": 10,
                "./tokentype": 14,
                "./util": 15
            } ],
            7: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _state = _dereq_("./state");
                var _locutil = _dereq_("./locutil");
                var Node = function Node(parser, pos, loc) {
                    _classCallCheck(this, Node);
                    this.type = "";
                    this.start = pos;
                    this.end = 0;
                    if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
                    if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
                    if (parser.options.ranges) this.range = [ pos, 0 ];
                };
                exports.Node = Node;
                var pp = _state.Parser.prototype;
                pp.startNode = function() {
                    return new Node(this, this.start, this.startLoc);
                };
                pp.startNodeAt = function(pos, loc) {
                    return new Node(this, pos, loc);
                };
                function finishNodeAt(node, type, pos, loc) {
                    node.type = type;
                    node.end = pos;
                    if (this.options.locations) node.loc.end = loc;
                    if (this.options.ranges) node.range[1] = pos;
                    return node;
                }
                pp.finishNode = function(node, type) {
                    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
                };
                pp.finishNodeAt = function(node, type, pos, loc) {
                    return finishNodeAt.call(this, node, type, pos, loc);
                };
            }, {
                "./locutil": 5,
                "./state": 10
            } ],
            8: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                exports.getOptions = getOptions;
                var _util = _dereq_("./util");
                var _locutil = _dereq_("./locutil");
                var defaultOptions = {
                    ecmaVersion: 6,
                    sourceType: "script",
                    onInsertedSemicolon: null,
                    onTrailingComma: null,
                    allowReserved: null,
                    allowReturnOutsideFunction: false,
                    allowImportExportEverywhere: false,
                    allowHashBang: false,
                    locations: false,
                    onToken: null,
                    onComment: null,
                    ranges: false,
                    program: null,
                    sourceFile: null,
                    directSourceFile: null,
                    preserveParens: false,
                    plugins: {}
                };
                exports.defaultOptions = defaultOptions;
                function getOptions(opts) {
                    var options = {};
                    for (var opt in defaultOptions) {
                        options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
                    }
                    if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
                    if (_util.isArray(options.onToken)) {
                        (function() {
                            var tokens = options.onToken;
                            options.onToken = function(token) {
                                return tokens.push(token);
                            };
                        })();
                    }
                    if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
                    return options;
                }
                function pushComment(options, array) {
                    return function(block, text, start, end, startLoc, endLoc) {
                        var comment = {
                            type: block ? "Block" : "Line",
                            value: text,
                            start: start,
                            end: end
                        };
                        if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
                        if (options.ranges) comment.range = [ start, end ];
                        array.push(comment);
                    };
                }
            }, {
                "./locutil": 5,
                "./util": 15
            } ],
            9: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _tokentype = _dereq_("./tokentype");
                var _state = _dereq_("./state");
                var _whitespace = _dereq_("./whitespace");
                var pp = _state.Parser.prototype;
                pp.isUseStrict = function(stmt) {
                    return false;
                };
                pp.eat = function(type) {
                    if (this.type === type) {
                        this.next();
                        return true;
                    } else {
                        return false;
                    }
                };
                pp.isContextual = function(name) {
                    return this.type === _tokentype.types.name && this.value === name;
                };
                pp.eatContextual = function(name) {
                    return this.value === name && this.eat(_tokentype.types.name);
                };
                pp.expectContextual = function(name) {
                    if (!this.eatContextual(name)) this.unexpected();
                };
                pp.canInsertSemicolon = function() {
                    return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
                };
                pp.insertSemicolon = function() {
                    if (this.canInsertSemicolon()) {
                        if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
                        return true;
                    }
                };
                pp.semicolon = function() {
                    if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
                };
                pp.afterTrailingComma = function(tokType) {
                    if (this.type == tokType) {
                        if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
                        this.next();
                        return true;
                    }
                };
                pp.expect = function(type) {
                    this.eat(type) || this.unexpected();
                };
                pp.unexpected = function(pos) {
                    this.raise(pos != null ? pos : this.start, "Unexpected token");
                };
                var DestructuringErrors = function DestructuringErrors() {
                    _classCallCheck(this, DestructuringErrors);
                    this.shorthandAssign = 0;
                    this.trailingComma = 0;
                };
                exports.DestructuringErrors = DestructuringErrors;
                pp.checkPatternErrors = function(refDestructuringErrors, andThrow) {
                    var trailing = refDestructuringErrors && refDestructuringErrors.trailingComma;
                    if (!andThrow) return !!trailing;
                    if (trailing) this.raise(trailing, "Comma is not permitted after the rest element");
                };
                pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
                    var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
                    if (!andThrow) return !!pos;
                    if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
                };
            }, {
                "./state": 10,
                "./tokentype": 14,
                "./whitespace": 16
            } ],
            10: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _identifier = _dereq_("./identifier");
                var _tokentype = _dereq_("./tokentype");
                var _whitespace = _dereq_("./whitespace");
                var _options = _dereq_("./options");
                var plugins = {};
                exports.plugins = plugins;
                function keywordRegexp(words) {
                    return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
                }
                var Parser = function() {
                    function Parser(options, input, startPos) {
                        _classCallCheck(this, Parser);
                        this.options = options = _options.getOptions(options);
                        this.sourceFile = options.sourceFile;
                        this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
                        var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
                        this.reservedWords = keywordRegexp(reserved);
                        var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
                        this.reservedWordsStrict = keywordRegexp(reservedStrict);
                        this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
                        this.input = String(input);
                        this.containsEsc = false;
                        this.loadPlugins(options.plugins);
                        if (startPos) {
                            this.pos = startPos;
                            this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
                            this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
                        } else {
                            this.pos = this.lineStart = 0;
                            this.curLine = 1;
                        }
                        this.type = _tokentype.types.eof;
                        this.value = null;
                        this.start = this.end = this.pos;
                        this.startLoc = this.endLoc = this.curPosition();
                        this.lastTokEndLoc = this.lastTokStartLoc = null;
                        this.lastTokStart = this.lastTokEnd = this.pos;
                        this.context = this.initialContext();
                        this.exprAllowed = true;
                        this.strict = this.inModule = options.sourceType === "module";
                        this.potentialArrowAt = -1;
                        this.inFunction = this.inGenerator = false;
                        this.labels = [];
                        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
                    }
                    Parser.prototype.isKeyword = function isKeyword(word) {
                        return this.keywords.test(word);
                    };
                    Parser.prototype.isReservedWord = function isReservedWord(word) {
                        return this.reservedWords.test(word);
                    };
                    Parser.prototype.extend = function extend(name, f) {
                        this[name] = f(this[name]);
                    };
                    Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
                        for (var _name in pluginConfigs) {
                            var plugin = plugins[_name];
                            if (!plugin) throw new Error("Plugin '" + _name + "' not found");
                            plugin(this, pluginConfigs[_name]);
                        }
                    };
                    Parser.prototype.parse = function parse() {
                        var node = this.options.program || this.startNode();
                        this.nextToken();
                        return this.parseTopLevel(node);
                    };
                    return Parser;
                }();
                exports.Parser = Parser;
            }, {
                "./identifier": 2,
                "./options": 8,
                "./tokentype": 14,
                "./whitespace": 16
            } ],
            11: [ function(_dereq_, module, exports) {
                "use strict";
                var _tokentype = _dereq_("./tokentype");
                var _state = _dereq_("./state");
                var _whitespace = _dereq_("./whitespace");
                var _identifier = _dereq_("./identifier");
                var _parseutil = _dereq_("./parseutil");
                var pp = _state.Parser.prototype;
                pp.parseTopLevel = function(node) {
                    var first = true;
                    if (!node.body) node.body = [];
                    while (this.type !== _tokentype.types.eof) {
                        var stmt = this.parseStatement(true, true);
                        node.body.push(stmt);
                        if (first) {
                            if (this.isUseStrict(stmt)) this.setStrict(true);
                            first = false;
                        }
                    }
                    this.next();
                    if (this.options.ecmaVersion >= 6) {
                        node.sourceType = this.options.sourceType;
                    }
                    return this.finishNode(node, "Program");
                };
                var loopLabel = {
                    kind: "loop"
                }, switchLabel = {
                    kind: "switch"
                };
                pp.isLet = function() {
                    if (this.type !== _tokentype.types.name || this.options.ecmaVersion < 6 || this.value != "let") return false;
                    _whitespace.skipWhiteSpace.lastIndex = this.pos;
                    var skip = _whitespace.skipWhiteSpace.exec(this.input);
                    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
                    if (nextCh === 91 || nextCh == 123) return true;
                    if (_identifier.isIdentifierStart(nextCh, true)) {
                        for (var pos = next + 1; _identifier.isIdentifierChar(this.input.charCodeAt(pos, true)); ++pos) {}
                        var ident = this.input.slice(next, pos);
                        if (!this.isKeyword(ident)) return true;
                    }
                    return false;
                };
                pp.parseStatement = function(declaration, topLevel) {
                    var starttype = this.type, node = this.startNode(), kind = undefined;
                    if (this.isLet()) {
                        starttype = _tokentype.types._var;
                        kind = "let";
                    }
                    switch (starttype) {
                      case _tokentype.types._break:
                      case _tokentype.types._continue:
                        return this.parseBreakContinueStatement(node, starttype.keyword);

                      case _tokentype.types._debugger:
                        return this.parseDebuggerStatement(node);

                      case _tokentype.types._do:
                        return this.parseDoStatement(node);

                      case _tokentype.types._for:
                        return this.parseForStatement(node);

                      case _tokentype.types._function:
                        if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
                        return this.parseFunctionStatement(node);

                      case _tokentype.types._class:
                        if (!declaration) this.unexpected();
                        return this.parseClass(node, true);

                      case _tokentype.types._if:
                        return this.parseIfStatement(node);

                      case _tokentype.types._return:
                        return this.parseReturnStatement(node);

                      case _tokentype.types._switch:
                        return this.parseSwitchStatement(node);

                      case _tokentype.types._throw:
                        return this.parseThrowStatement(node);

                      case _tokentype.types._try:
                        return this.parseTryStatement(node);

                      case _tokentype.types._const:
                      case _tokentype.types._var:
                        kind = kind || this.value;
                        if (!declaration && kind != "var") this.unexpected();
                        return this.parseVarStatement(node, kind);

                      case _tokentype.types._while:
                        return this.parseWhileStatement(node);

                      case _tokentype.types._with:
                        return this.parseWithStatement(node);

                      case _tokentype.types.braceL:
                        return this.parseBlock();

                      case _tokentype.types.semi:
                        return this.parseEmptyStatement(node);

                      case _tokentype.types._export:
                      case _tokentype.types._import:
                        if (!this.options.allowImportExportEverywhere) {
                            if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
                            if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
                        }
                        return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);

                      default:
                        var maybeName = this.value, expr = this.parseExpression();
                        if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr); else return this.parseExpressionStatement(node, expr);
                    }
                };
                pp.parseBreakContinueStatement = function(node, keyword) {
                    var isBreak = keyword == "break";
                    this.next();
                    if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null; else if (this.type !== _tokentype.types.name) this.unexpected(); else {
                        node.label = this.parseIdent();
                        this.semicolon();
                    }
                    for (var i = 0; i < this.labels.length; ++i) {
                        var lab = this.labels[i];
                        if (node.label == null || lab.name === node.label.name) {
                            if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
                            if (node.label && isBreak) break;
                        }
                    }
                    if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
                    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
                };
                pp.parseDebuggerStatement = function(node) {
                    this.next();
                    this.semicolon();
                    return this.finishNode(node, "DebuggerStatement");
                };
                pp.parseDoStatement = function(node) {
                    this.next();
                    this.labels.push(loopLabel);
                    node.body = this.parseStatement(false);
                    this.labels.pop();
                    this.expect(_tokentype.types._while);
                    node.test = this.parseParenExpression();
                    if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi); else this.semicolon();
                    return this.finishNode(node, "DoWhileStatement");
                };
                pp.parseForStatement = function(node) {
                    this.next();
                    this.labels.push(loopLabel);
                    this.expect(_tokentype.types.parenL);
                    if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
                    var isLet = this.isLet();
                    if (this.type === _tokentype.types._var || this.type === _tokentype.types._const || isLet) {
                        var _init = this.startNode(), kind = isLet ? "let" : this.value;
                        this.next();
                        this.parseVar(_init, true, kind);
                        this.finishNode(_init, "VariableDeclaration");
                        if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(kind !== "var" && _init.declarations[0].init)) return this.parseForIn(node, _init);
                        return this.parseFor(node, _init);
                    }
                    var refDestructuringErrors = new _parseutil.DestructuringErrors();
                    var init = this.parseExpression(true, refDestructuringErrors);
                    if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
                        this.checkPatternErrors(refDestructuringErrors, true);
                        this.toAssignable(init);
                        this.checkLVal(init);
                        return this.parseForIn(node, init);
                    } else {
                        this.checkExpressionErrors(refDestructuringErrors, true);
                    }
                    return this.parseFor(node, init);
                };
                pp.parseFunctionStatement = function(node) {
                    this.next();
                    return this.parseFunction(node, true);
                };
                pp.parseIfStatement = function(node) {
                    this.next();
                    node.test = this.parseParenExpression();
                    node.consequent = this.parseStatement(false);
                    node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
                    return this.finishNode(node, "IfStatement");
                };
                pp.parseReturnStatement = function(node) {
                    if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
                    this.next();
                    if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null; else {
                        node.argument = this.parseExpression();
                        this.semicolon();
                    }
                    return this.finishNode(node, "ReturnStatement");
                };
                pp.parseSwitchStatement = function(node) {
                    this.next();
                    node.discriminant = this.parseParenExpression();
                    node.cases = [];
                    this.expect(_tokentype.types.braceL);
                    this.labels.push(switchLabel);
                    for (var cur, sawDefault = false; this.type != _tokentype.types.braceR; ) {
                        if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
                            var isCase = this.type === _tokentype.types._case;
                            if (cur) this.finishNode(cur, "SwitchCase");
                            node.cases.push(cur = this.startNode());
                            cur.consequent = [];
                            this.next();
                            if (isCase) {
                                cur.test = this.parseExpression();
                            } else {
                                if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
                                sawDefault = true;
                                cur.test = null;
                            }
                            this.expect(_tokentype.types.colon);
                        } else {
                            if (!cur) this.unexpected();
                            cur.consequent.push(this.parseStatement(true));
                        }
                    }
                    if (cur) this.finishNode(cur, "SwitchCase");
                    this.next();
                    this.labels.pop();
                    return this.finishNode(node, "SwitchStatement");
                };
                pp.parseThrowStatement = function(node) {
                    this.next();
                    if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
                    node.argument = this.parseExpression();
                    this.semicolon();
                    return this.finishNode(node, "ThrowStatement");
                };
                var empty = [];
                pp.parseTryStatement = function(node) {
                    this.next();
                    node.block = this.parseBlock();
                    node.handler = null;
                    if (this.type === _tokentype.types._catch) {
                        var clause = this.startNode();
                        this.next();
                        this.expect(_tokentype.types.parenL);
                        clause.param = this.parseBindingAtom();
                        this.checkLVal(clause.param, true);
                        this.expect(_tokentype.types.parenR);
                        clause.body = this.parseBlock();
                        node.handler = this.finishNode(clause, "CatchClause");
                    }
                    node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
                    if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
                    return this.finishNode(node, "TryStatement");
                };
                pp.parseVarStatement = function(node, kind) {
                    this.next();
                    this.parseVar(node, false, kind);
                    this.semicolon();
                    return this.finishNode(node, "VariableDeclaration");
                };
                pp.parseWhileStatement = function(node) {
                    this.next();
                    node.test = this.parseParenExpression();
                    this.labels.push(loopLabel);
                    node.body = this.parseStatement(false);
                    this.labels.pop();
                    return this.finishNode(node, "WhileStatement");
                };
                pp.parseWithStatement = function(node) {
                    if (this.strict) this.raise(this.start, "'with' in strict mode");
                    this.next();
                    node.object = this.parseParenExpression();
                    node.body = this.parseStatement(false);
                    return this.finishNode(node, "WithStatement");
                };
                pp.parseEmptyStatement = function(node) {
                    this.next();
                    return this.finishNode(node, "EmptyStatement");
                };
                pp.parseLabeledStatement = function(node, maybeName, expr) {
                    for (var i = 0; i < this.labels.length; ++i) {
                        if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
                    }
                    var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
                    for (var i = this.labels.length - 1; i >= 0; i--) {
                        var label = this.labels[i];
                        if (label.statementStart == node.start) {
                            label.statementStart = this.start;
                            label.kind = kind;
                        } else break;
                    }
                    this.labels.push({
                        name: maybeName,
                        kind: kind,
                        statementStart: this.start
                    });
                    node.body = this.parseStatement(true);
                    this.labels.pop();
                    node.label = expr;
                    return this.finishNode(node, "LabeledStatement");
                };
                pp.parseExpressionStatement = function(node, expr) {
                    node.expression = expr;
                    this.semicolon();
                    return this.finishNode(node, "ExpressionStatement");
                };
                pp.parseBlock = function(allowStrict) {
                    var node = this.startNode(), first = true, oldStrict = undefined;
                    node.body = [];
                    this.expect(_tokentype.types.braceL);
                    while (!this.eat(_tokentype.types.braceR)) {
                        var stmt = this.parseStatement(true);
                        node.body.push(stmt);
                        if (first && allowStrict && this.isUseStrict(stmt)) {
                            oldStrict = this.strict;
                            this.setStrict(this.strict = true);
                        }
                        first = false;
                    }
                    if (oldStrict === false) this.setStrict(false);
                    return this.finishNode(node, "BlockStatement");
                };
                pp.parseFor = function(node, init) {
                    node.init = init;
                    this.expect(_tokentype.types.semi);
                    node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
                    this.expect(_tokentype.types.semi);
                    node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
                    this.expect(_tokentype.types.parenR);
                    node.body = this.parseStatement(false);
                    this.labels.pop();
                    return this.finishNode(node, "ForStatement");
                };
                pp.parseForIn = function(node, init) {
                    var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
                    this.next();
                    node.left = init;
                    node.right = this.parseExpression();
                    this.expect(_tokentype.types.parenR);
                    node.body = this.parseStatement(false);
                    this.labels.pop();
                    return this.finishNode(node, type);
                };
                pp.parseVar = function(node, isFor, kind) {
                    node.declarations = [];
                    node.kind = kind;
                    for (;;) {
                        var decl = this.startNode();
                        this.parseVarId(decl);
                        if (this.eat(_tokentype.types.eq)) {
                            decl.init = this.parseMaybeAssign(isFor);
                        } else if (kind === "const" && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
                            this.unexpected();
                        } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
                            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
                        } else {
                            decl.init = null;
                        }
                        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
                        if (!this.eat(_tokentype.types.comma)) break;
                    }
                    return node;
                };
                pp.parseVarId = function(decl) {
                    decl.id = this.parseBindingAtom();
                    this.checkLVal(decl.id, true);
                };
                pp.parseFunction = function(node, isStatement, allowExpressionBody) {
                    this.initFunction(node);
                    if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
                    var oldInGen = this.inGenerator;
                    this.inGenerator = node.generator;
                    if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
                    this.parseFunctionParams(node);
                    this.parseFunctionBody(node, allowExpressionBody);
                    this.inGenerator = oldInGen;
                    return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
                };
                pp.parseFunctionParams = function(node) {
                    this.expect(_tokentype.types.parenL);
                    node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
                };
                pp.parseClass = function(node, isStatement) {
                    this.next();
                    this.parseClassId(node, isStatement);
                    this.parseClassSuper(node);
                    var classBody = this.startNode();
                    var hadConstructor = false;
                    classBody.body = [];
                    this.expect(_tokentype.types.braceL);
                    while (!this.eat(_tokentype.types.braceR)) {
                        if (this.eat(_tokentype.types.semi)) continue;
                        var method = this.startNode();
                        var isGenerator = this.eat(_tokentype.types.star);
                        var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
                        this.parsePropertyName(method);
                        method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
                        if (method["static"]) {
                            if (isGenerator) this.unexpected();
                            isGenerator = this.eat(_tokentype.types.star);
                            this.parsePropertyName(method);
                        }
                        method.kind = "method";
                        var isGetSet = false;
                        if (!method.computed) {
                            var key = method.key;
                            if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
                                isGetSet = true;
                                method.kind = key.name;
                                key = this.parsePropertyName(method);
                            }
                            if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
                                if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
                                if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
                                if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
                                method.kind = "constructor";
                                hadConstructor = true;
                            }
                        }
                        this.parseClassMethod(classBody, method, isGenerator);
                        if (isGetSet) {
                            var paramCount = method.kind === "get" ? 0 : 1;
                            if (method.value.params.length !== paramCount) {
                                var start = method.value.start;
                                if (method.kind === "get") this.raiseRecoverable(start, "getter should have no params"); else this.raiseRecoverable(start, "setter should have exactly one param");
                            }
                            if (method.kind === "set" && method.value.params[0].type === "RestElement") this.raise(method.value.params[0].start, "Setter cannot use rest params");
                        }
                    }
                    node.body = this.finishNode(classBody, "ClassBody");
                    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
                };
                pp.parseClassMethod = function(classBody, method, isGenerator) {
                    method.value = this.parseMethod(isGenerator);
                    classBody.body.push(this.finishNode(method, "MethodDefinition"));
                };
                pp.parseClassId = function(node, isStatement) {
                    node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
                };
                pp.parseClassSuper = function(node) {
                    node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
                };
                pp.parseExport = function(node) {
                    this.next();
                    if (this.eat(_tokentype.types.star)) {
                        this.expectContextual("from");
                        node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
                        this.semicolon();
                        return this.finishNode(node, "ExportAllDeclaration");
                    }
                    if (this.eat(_tokentype.types._default)) {
                        var parens = this.type == _tokentype.types.parenL;
                        var expr = this.parseMaybeAssign();
                        var needsSemi = true;
                        if (!parens && (expr.type == "FunctionExpression" || expr.type == "ClassExpression")) {
                            needsSemi = false;
                            if (expr.id) {
                                expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
                            }
                        }
                        node.declaration = expr;
                        if (needsSemi) this.semicolon();
                        return this.finishNode(node, "ExportDefaultDeclaration");
                    }
                    if (this.shouldParseExportStatement()) {
                        node.declaration = this.parseStatement(true);
                        node.specifiers = [];
                        node.source = null;
                    } else {
                        node.declaration = null;
                        node.specifiers = this.parseExportSpecifiers();
                        if (this.eatContextual("from")) {
                            node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
                        } else {
                            for (var i = 0; i < node.specifiers.length; i++) {
                                if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
                                    this.unexpected(node.specifiers[i].local.start);
                                }
                            }
                            node.source = null;
                        }
                        this.semicolon();
                    }
                    return this.finishNode(node, "ExportNamedDeclaration");
                };
                pp.shouldParseExportStatement = function() {
                    return this.type.keyword || this.isLet();
                };
                pp.parseExportSpecifiers = function() {
                    var nodes = [], first = true;
                    this.expect(_tokentype.types.braceL);
                    while (!this.eat(_tokentype.types.braceR)) {
                        if (!first) {
                            this.expect(_tokentype.types.comma);
                            if (this.afterTrailingComma(_tokentype.types.braceR)) break;
                        } else first = false;
                        var node = this.startNode();
                        node.local = this.parseIdent(this.type === _tokentype.types._default);
                        node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
                        nodes.push(this.finishNode(node, "ExportSpecifier"));
                    }
                    return nodes;
                };
                pp.parseImport = function(node) {
                    this.next();
                    if (this.type === _tokentype.types.string) {
                        node.specifiers = empty;
                        node.source = this.parseExprAtom();
                    } else {
                        node.specifiers = this.parseImportSpecifiers();
                        this.expectContextual("from");
                        node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
                    }
                    this.semicolon();
                    return this.finishNode(node, "ImportDeclaration");
                };
                pp.parseImportSpecifiers = function() {
                    var nodes = [], first = true;
                    if (this.type === _tokentype.types.name) {
                        var node = this.startNode();
                        node.local = this.parseIdent();
                        this.checkLVal(node.local, true);
                        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
                        if (!this.eat(_tokentype.types.comma)) return nodes;
                    }
                    if (this.type === _tokentype.types.star) {
                        var node = this.startNode();
                        this.next();
                        this.expectContextual("as");
                        node.local = this.parseIdent();
                        this.checkLVal(node.local, true);
                        nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
                        return nodes;
                    }
                    this.expect(_tokentype.types.braceL);
                    while (!this.eat(_tokentype.types.braceR)) {
                        if (!first) {
                            this.expect(_tokentype.types.comma);
                            if (this.afterTrailingComma(_tokentype.types.braceR)) break;
                        } else first = false;
                        var node = this.startNode();
                        node.imported = this.parseIdent(true);
                        if (this.eatContextual("as")) {
                            node.local = this.parseIdent();
                        } else {
                            node.local = node.imported;
                            if (this.isKeyword(node.local.name)) this.unexpected(node.local.start);
                            if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, "The keyword '" + node.local.name + "' is reserved");
                        }
                        this.checkLVal(node.local, true);
                        nodes.push(this.finishNode(node, "ImportSpecifier"));
                    }
                    return nodes;
                };
            }, {
                "./identifier": 2,
                "./parseutil": 9,
                "./state": 10,
                "./tokentype": 14,
                "./whitespace": 16
            } ],
            12: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _state = _dereq_("./state");
                var _tokentype = _dereq_("./tokentype");
                var _whitespace = _dereq_("./whitespace");
                var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
                    _classCallCheck(this, TokContext);
                    this.token = token;
                    this.isExpr = !!isExpr;
                    this.preserveSpace = !!preserveSpace;
                    this.override = override;
                };
                exports.TokContext = TokContext;
                var types = {
                    b_stat: new TokContext("{", false),
                    b_expr: new TokContext("{", true),
                    b_tmpl: new TokContext("${", true),
                    p_stat: new TokContext("(", false),
                    p_expr: new TokContext("(", true),
                    q_tmpl: new TokContext("`", true, true, function(p) {
                        return p.readTmplToken();
                    }),
                    f_expr: new TokContext("function", true)
                };
                exports.types = types;
                var pp = _state.Parser.prototype;
                pp.initialContext = function() {
                    return [ types.b_stat ];
                };
                pp.braceIsBlock = function(prevType) {
                    if (prevType === _tokentype.types.colon) {
                        var _parent = this.curContext();
                        if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
                    }
                    if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
                    if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
                    if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
                    return !this.exprAllowed;
                };
                pp.updateContext = function(prevType) {
                    var update = undefined, type = this.type;
                    if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false; else if (update = type.updateContext) update.call(this, prevType); else this.exprAllowed = type.beforeExpr;
                };
                _tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function() {
                    if (this.context.length == 1) {
                        this.exprAllowed = true;
                        return;
                    }
                    var out = this.context.pop();
                    if (out === types.b_stat && this.curContext() === types.f_expr) {
                        this.context.pop();
                        this.exprAllowed = false;
                    } else if (out === types.b_tmpl) {
                        this.exprAllowed = true;
                    } else {
                        this.exprAllowed = !out.isExpr;
                    }
                };
                _tokentype.types.braceL.updateContext = function(prevType) {
                    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
                    this.exprAllowed = true;
                };
                _tokentype.types.dollarBraceL.updateContext = function() {
                    this.context.push(types.b_tmpl);
                    this.exprAllowed = true;
                };
                _tokentype.types.parenL.updateContext = function(prevType) {
                    var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
                    this.context.push(statementParens ? types.p_stat : types.p_expr);
                    this.exprAllowed = true;
                };
                _tokentype.types.incDec.updateContext = function() {};
                _tokentype.types._function.updateContext = function(prevType) {
                    if (prevType.beforeExpr && prevType !== _tokentype.types.semi && prevType !== _tokentype.types._else && (prevType !== _tokentype.types.colon || this.curContext() !== types.b_stat)) this.context.push(types.f_expr);
                    this.exprAllowed = false;
                };
                _tokentype.types.backQuote.updateContext = function() {
                    if (this.curContext() === types.q_tmpl) this.context.pop(); else this.context.push(types.q_tmpl);
                    this.exprAllowed = false;
                };
            }, {
                "./state": 10,
                "./tokentype": 14,
                "./whitespace": 16
            } ],
            13: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _identifier = _dereq_("./identifier");
                var _tokentype = _dereq_("./tokentype");
                var _state = _dereq_("./state");
                var _locutil = _dereq_("./locutil");
                var _whitespace = _dereq_("./whitespace");
                var Token = function Token(p) {
                    _classCallCheck(this, Token);
                    this.type = p.type;
                    this.value = p.value;
                    this.start = p.start;
                    this.end = p.end;
                    if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
                    if (p.options.ranges) this.range = [ p.start, p.end ];
                };
                exports.Token = Token;
                var pp = _state.Parser.prototype;
                var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";
                pp.next = function() {
                    if (this.options.onToken) this.options.onToken(new Token(this));
                    this.lastTokEnd = this.end;
                    this.lastTokStart = this.start;
                    this.lastTokEndLoc = this.endLoc;
                    this.lastTokStartLoc = this.startLoc;
                    this.nextToken();
                };
                pp.getToken = function() {
                    this.next();
                    return new Token(this);
                };
                if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function() {
                    var self = this;
                    return {
                        next: function next() {
                            var token = self.getToken();
                            return {
                                done: token.type === _tokentype.types.eof,
                                value: token
                            };
                        }
                    };
                };
                pp.setStrict = function(strict) {
                    this.strict = strict;
                    if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
                    this.pos = this.start;
                    if (this.options.locations) {
                        while (this.pos < this.lineStart) {
                            this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
                            --this.curLine;
                        }
                    }
                    this.nextToken();
                };
                pp.curContext = function() {
                    return this.context[this.context.length - 1];
                };
                pp.nextToken = function() {
                    var curContext = this.curContext();
                    if (!curContext || !curContext.preserveSpace) this.skipSpace();
                    this.start = this.pos;
                    if (this.options.locations) this.startLoc = this.curPosition();
                    if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);
                    if (curContext.override) return curContext.override(this); else this.readToken(this.fullCharCodeAtPos());
                };
                pp.readToken = function(code) {
                    if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) return this.readWord();
                    return this.getTokenFromCode(code);
                };
                pp.fullCharCodeAtPos = function() {
                    var code = this.input.charCodeAt(this.pos);
                    if (code <= 55295 || code >= 57344) return code;
                    var next = this.input.charCodeAt(this.pos + 1);
                    return (code << 10) + next - 56613888;
                };
                pp.skipBlockComment = function() {
                    var startLoc = this.options.onComment && this.curPosition();
                    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
                    if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
                    this.pos = end + 2;
                    if (this.options.locations) {
                        _whitespace.lineBreakG.lastIndex = start;
                        var match = undefined;
                        while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
                            ++this.curLine;
                            this.lineStart = match.index + match[0].length;
                        }
                    }
                    if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
                };
                pp.skipLineComment = function(startSkip) {
                    var start = this.pos;
                    var startLoc = this.options.onComment && this.curPosition();
                    var ch = this.input.charCodeAt(this.pos += startSkip);
                    while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
                        ++this.pos;
                        ch = this.input.charCodeAt(this.pos);
                    }
                    if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
                };
                pp.skipSpace = function() {
                    loop: while (this.pos < this.input.length) {
                        var ch = this.input.charCodeAt(this.pos);
                        switch (ch) {
                          case 32:
                          case 160:
                            ++this.pos;
                            break;

                          case 13:
                            if (this.input.charCodeAt(this.pos + 1) === 10) {
                                ++this.pos;
                            }

                          case 10:
                          case 8232:
                          case 8233:
                            ++this.pos;
                            if (this.options.locations) {
                                ++this.curLine;
                                this.lineStart = this.pos;
                            }
                            break;

                          case 47:
                            switch (this.input.charCodeAt(this.pos + 1)) {
                              case 42:
                                this.skipBlockComment();
                                break;

                              case 47:
                                this.skipLineComment(2);
                                break;

                              default:
                                break loop;
                            }
                            break;

                          default:
                            if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                                ++this.pos;
                            } else {
                                break loop;
                            }
                        }
                    }
                };
                pp.finishToken = function(type, val) {
                    this.end = this.pos;
                    if (this.options.locations) this.endLoc = this.curPosition();
                    var prevType = this.type;
                    this.type = type;
                    this.value = val;
                    this.updateContext(prevType);
                };
                pp.readToken_dot = function() {
                    var next = this.input.charCodeAt(this.pos + 1);
                    if (next >= 48 && next <= 57) return this.readNumber(true);
                    var next2 = this.input.charCodeAt(this.pos + 2);
                    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
                        this.pos += 3;
                        return this.finishToken(_tokentype.types.ellipsis);
                    } else {
                        ++this.pos;
                        return this.finishToken(_tokentype.types.dot);
                    }
                };
                pp.readToken_slash = function() {
                    var next = this.input.charCodeAt(this.pos + 1);
                    if (this.exprAllowed) {
                        ++this.pos;
                        return this.readRegexp();
                    }
                    if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
                    return this.finishOp(_tokentype.types.slash, 1);
                };
                pp.readToken_mult_modulo_exp = function(code) {
                    var next = this.input.charCodeAt(this.pos + 1);
                    var size = 1;
                    var tokentype = code === 42 ? _tokentype.types.star : _tokentype.types.modulo;
                    if (this.options.ecmaVersion >= 7 && next === 42) {
                        ++size;
                        tokentype = _tokentype.types.starstar;
                        next = this.input.charCodeAt(this.pos + 2);
                    }
                    if (next === 61) return this.finishOp(_tokentype.types.assign, size + 1);
                    return this.finishOp(tokentype, size);
                };
                pp.readToken_pipe_amp = function(code) {
                    var next = this.input.charCodeAt(this.pos + 1);
                    if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
                    if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
                    return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
                };
                pp.readToken_caret = function() {
                    var next = this.input.charCodeAt(this.pos + 1);
                    if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
                    return this.finishOp(_tokentype.types.bitwiseXOR, 1);
                };
                pp.readToken_plus_min = function(code) {
                    var next = this.input.charCodeAt(this.pos + 1);
                    if (next === code) {
                        if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
                            this.skipLineComment(3);
                            this.skipSpace();
                            return this.nextToken();
                        }
                        return this.finishOp(_tokentype.types.incDec, 2);
                    }
                    if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
                    return this.finishOp(_tokentype.types.plusMin, 1);
                };
                pp.readToken_lt_gt = function(code) {
                    var next = this.input.charCodeAt(this.pos + 1);
                    var size = 1;
                    if (next === code) {
                        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
                        if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
                        return this.finishOp(_tokentype.types.bitShift, size);
                    }
                    if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
                        if (this.inModule) this.unexpected();
                        this.skipLineComment(4);
                        this.skipSpace();
                        return this.nextToken();
                    }
                    if (next === 61) size = 2;
                    return this.finishOp(_tokentype.types.relational, size);
                };
                pp.readToken_eq_excl = function(code) {
                    var next = this.input.charCodeAt(this.pos + 1);
                    if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
                    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
                        this.pos += 2;
                        return this.finishToken(_tokentype.types.arrow);
                    }
                    return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
                };
                pp.getTokenFromCode = function(code) {
                    switch (code) {
                      case 46:
                        return this.readToken_dot();

                      case 40:
                        ++this.pos;
                        return this.finishToken(_tokentype.types.parenL);

                      case 41:
                        ++this.pos;
                        return this.finishToken(_tokentype.types.parenR);

                      case 59:
                        ++this.pos;
                        return this.finishToken(_tokentype.types.semi);

                      case 44:
                        ++this.pos;
                        return this.finishToken(_tokentype.types.comma);

                      case 91:
                        ++this.pos;
                        return this.finishToken(_tokentype.types.bracketL);

                      case 93:
                        ++this.pos;
                        return this.finishToken(_tokentype.types.bracketR);

                      case 123:
                        ++this.pos;
                        return this.finishToken(_tokentype.types.braceL);

                      case 125:
                        ++this.pos;
                        return this.finishToken(_tokentype.types.braceR);

                      case 58:
                        ++this.pos;
                        return this.finishToken(_tokentype.types.colon);

                      case 63:
                        ++this.pos;
                        return this.finishToken(_tokentype.types.question);

                      case 96:
                        if (this.options.ecmaVersion < 6) break;
                        ++this.pos;
                        return this.finishToken(_tokentype.types.backQuote);

                      case 48:
                        var next = this.input.charCodeAt(this.pos + 1);
                        if (next === 120 || next === 88) return this.readRadixNumber(16);
                        if (this.options.ecmaVersion >= 6) {
                            if (next === 111 || next === 79) return this.readRadixNumber(8);
                            if (next === 98 || next === 66) return this.readRadixNumber(2);
                        }

                      case 49:
                      case 50:
                      case 51:
                      case 52:
                      case 53:
                      case 54:
                      case 55:
                      case 56:
                      case 57:
                        return this.readNumber(false);

                      case 34:
                      case 39:
                        return this.readString(code);

                      case 47:
                        return this.readToken_slash();

                      case 37:
                      case 42:
                        return this.readToken_mult_modulo_exp(code);

                      case 124:
                      case 38:
                        return this.readToken_pipe_amp(code);

                      case 94:
                        return this.readToken_caret();

                      case 43:
                      case 45:
                        return this.readToken_plus_min(code);

                      case 60:
                      case 62:
                        return this.readToken_lt_gt(code);

                      case 61:
                      case 33:
                        return this.readToken_eq_excl(code);

                      case 126:
                        return this.finishOp(_tokentype.types.prefix, 1);
                    }
                    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
                };
                pp.finishOp = function(type, size) {
                    var str = this.input.slice(this.pos, this.pos + size);
                    this.pos += size;
                    return this.finishToken(type, str);
                };
                function tryCreateRegexp(src, flags, throwErrorAt, parser) {
                    try {
                        return new RegExp(src, flags);
                    } catch (e) {
                        if (throwErrorAt !== undefined) {
                            if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
                            throw e;
                        }
                    }
                }
                var regexpUnicodeSupport = !!tryCreateRegexp("￿", "u");
                pp.readRegexp = function() {
                    var _this = this;
                    var escaped = undefined, inClass = undefined, start = this.pos;
                    for (;;) {
                        if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
                        var ch = this.input.charAt(this.pos);
                        if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
                        if (!escaped) {
                            if (ch === "[") inClass = true; else if (ch === "]" && inClass) inClass = false; else if (ch === "/" && !inClass) break;
                            escaped = ch === "\\";
                        } else escaped = false;
                        ++this.pos;
                    }
                    var content = this.input.slice(start, this.pos);
                    ++this.pos;
                    var mods = this.readWord1();
                    var tmp = content, tmpFlags = "";
                    if (mods) {
                        var validFlags = /^[gim]*$/;
                        if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;
                        if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
                        if (mods.indexOf("u") >= 0) {
                            if (regexpUnicodeSupport) {
                                tmpFlags = "u";
                            } else {
                                tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function(_match, code, offset) {
                                    code = Number("0x" + code);
                                    if (code > 1114111) _this.raise(start + offset + 3, "Code point out of bounds");
                                    return "x";
                                });
                                tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
                                tmpFlags = tmpFlags.replace("u", "");
                            }
                        }
                    }
                    var value = null;
                    if (!isRhino) {
                        tryCreateRegexp(tmp, tmpFlags, start, this);
                        value = tryCreateRegexp(content, mods);
                    }
                    return this.finishToken(_tokentype.types.regexp, {
                        pattern: content,
                        flags: mods,
                        value: value
                    });
                };
                pp.readInt = function(radix, len) {
                    var start = this.pos, total = 0;
                    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
                        var code = this.input.charCodeAt(this.pos), val = undefined;
                        if (code >= 97) val = code - 97 + 10; else if (code >= 65) val = code - 65 + 10; else if (code >= 48 && code <= 57) val = code - 48; else val = Infinity;
                        if (val >= radix) break;
                        ++this.pos;
                        total = total * radix + val;
                    }
                    if (this.pos === start || len != null && this.pos - start !== len) return null;
                    return total;
                };
                pp.readRadixNumber = function(radix) {
                    this.pos += 2;
                    var val = this.readInt(radix);
                    if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
                    if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
                    return this.finishToken(_tokentype.types.num, val);
                };
                pp.readNumber = function(startsWithDot) {
                    var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48;
                    if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
                    var next = this.input.charCodeAt(this.pos);
                    if (next === 46) {
                        ++this.pos;
                        this.readInt(10);
                        isFloat = true;
                        next = this.input.charCodeAt(this.pos);
                    }
                    if (next === 69 || next === 101) {
                        next = this.input.charCodeAt(++this.pos);
                        if (next === 43 || next === 45) ++this.pos;
                        if (this.readInt(10) === null) this.raise(start, "Invalid number");
                        isFloat = true;
                    }
                    if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
                    var str = this.input.slice(start, this.pos), val = undefined;
                    if (isFloat) val = parseFloat(str); else if (!octal || str.length === 1) val = parseInt(str, 10); else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number"); else val = parseInt(str, 8);
                    return this.finishToken(_tokentype.types.num, val);
                };
                pp.readCodePoint = function() {
                    var ch = this.input.charCodeAt(this.pos), code = undefined;
                    if (ch === 123) {
                        if (this.options.ecmaVersion < 6) this.unexpected();
                        var codePos = ++this.pos;
                        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
                        ++this.pos;
                        if (code > 1114111) this.raise(codePos, "Code point out of bounds");
                    } else {
                        code = this.readHexChar(4);
                    }
                    return code;
                };
                function codePointToString(code) {
                    if (code <= 65535) return String.fromCharCode(code);
                    code -= 65536;
                    return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
                }
                pp.readString = function(quote) {
                    var out = "", chunkStart = ++this.pos;
                    for (;;) {
                        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
                        var ch = this.input.charCodeAt(this.pos);
                        if (ch === quote) break;
                        if (ch === 92) {
                            out += this.input.slice(chunkStart, this.pos);
                            out += this.readEscapedChar(false);
                            chunkStart = this.pos;
                        } else {
                            if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
                            ++this.pos;
                        }
                    }
                    out += this.input.slice(chunkStart, this.pos++);
                    return this.finishToken(_tokentype.types.string, out);
                };
                pp.readTmplToken = function() {
                    var out = "", chunkStart = this.pos;
                    for (;;) {
                        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
                        var ch = this.input.charCodeAt(this.pos);
                        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
                            if (this.pos === this.start && this.type === _tokentype.types.template) {
                                if (ch === 36) {
                                    this.pos += 2;
                                    return this.finishToken(_tokentype.types.dollarBraceL);
                                } else {
                                    ++this.pos;
                                    return this.finishToken(_tokentype.types.backQuote);
                                }
                            }
                            out += this.input.slice(chunkStart, this.pos);
                            return this.finishToken(_tokentype.types.template, out);
                        }
                        if (ch === 92) {
                            out += this.input.slice(chunkStart, this.pos);
                            out += this.readEscapedChar(true);
                            chunkStart = this.pos;
                        } else if (_whitespace.isNewLine(ch)) {
                            out += this.input.slice(chunkStart, this.pos);
                            ++this.pos;
                            switch (ch) {
                              case 13:
                                if (this.input.charCodeAt(this.pos) === 10) ++this.pos;

                              case 10:
                                out += "\n";
                                break;

                              default:
                                out += String.fromCharCode(ch);
                                break;
                            }
                            if (this.options.locations) {
                                ++this.curLine;
                                this.lineStart = this.pos;
                            }
                            chunkStart = this.pos;
                        } else {
                            ++this.pos;
                        }
                    }
                };
                pp.readEscapedChar = function(inTemplate) {
                    var ch = this.input.charCodeAt(++this.pos);
                    ++this.pos;
                    switch (ch) {
                      case 110:
                        return "\n";

                      case 114:
                        return "\r";

                      case 120:
                        return String.fromCharCode(this.readHexChar(2));

                      case 117:
                        return codePointToString(this.readCodePoint());

                      case 116:
                        return "\t";

                      case 98:
                        return "\b";

                      case 118:
                        return "\x0B";

                      case 102:
                        return "\f";

                      case 13:
                        if (this.input.charCodeAt(this.pos) === 10) ++this.pos;

                      case 10:
                        if (this.options.locations) {
                            this.lineStart = this.pos;
                            ++this.curLine;
                        }
                        return "";

                      default:
                        if (ch >= 48 && ch <= 55) {
                            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                            var octal = parseInt(octalStr, 8);
                            if (octal > 255) {
                                octalStr = octalStr.slice(0, -1);
                                octal = parseInt(octalStr, 8);
                            }
                            if (octalStr !== "0" && (this.strict || inTemplate)) {
                                this.raise(this.pos - 2, "Octal literal in strict mode");
                            }
                            this.pos += octalStr.length - 1;
                            return String.fromCharCode(octal);
                        }
                        return String.fromCharCode(ch);
                    }
                };
                pp.readHexChar = function(len) {
                    var codePos = this.pos;
                    var n = this.readInt(16, len);
                    if (n === null) this.raise(codePos, "Bad character escape sequence");
                    return n;
                };
                pp.readWord1 = function() {
                    this.containsEsc = false;
                    var word = "", first = true, chunkStart = this.pos;
                    var astral = this.options.ecmaVersion >= 6;
                    while (this.pos < this.input.length) {
                        var ch = this.fullCharCodeAtPos();
                        if (_identifier.isIdentifierChar(ch, astral)) {
                            this.pos += ch <= 65535 ? 1 : 2;
                        } else if (ch === 92) {
                            this.containsEsc = true;
                            word += this.input.slice(chunkStart, this.pos);
                            var escStart = this.pos;
                            if (this.input.charCodeAt(++this.pos) != 117) this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
                            ++this.pos;
                            var esc = this.readCodePoint();
                            if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
                            word += this.input.substr(this.pos - 6, 6);
                            chunkStart = this.pos;
                        } else {
                            break;
                        }
                        first = false;
                    }
                    return word + this.input.slice(chunkStart, this.pos);
                };
                pp.readWord = function() {
                    var word = this.readWord1();
                    var type = _tokentype.types.name;
                    if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
                    return this.finishToken(type, word);
                };
            }, {
                "./identifier": 2,
                "./locutil": 5,
                "./state": 10,
                "./tokentype": 14,
                "./whitespace": 16
            } ],
            14: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var TokenType = function TokenType(label) {
                    var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                    _classCallCheck(this, TokenType);
                    this.label = label;
                    this.keyword = conf.keyword;
                    this.beforeExpr = !!conf.beforeExpr;
                    this.startsExpr = !!conf.startsExpr;
                    this.isLoop = !!conf.isLoop;
                    this.isAssign = !!conf.isAssign;
                    this.prefix = !!conf.prefix;
                    this.postfix = !!conf.postfix;
                    this.binop = conf.binop || null;
                    this.updateContext = null;
                };
                exports.TokenType = TokenType;
                function binop(name, prec) {
                    return new TokenType(name, {
                        beforeExpr: true,
                        binop: prec
                    });
                }
                var beforeExpr = {
                    beforeExpr: true
                }, startsExpr = {
                    startsExpr: true
                };
                var types = {
                    num: new TokenType("num", startsExpr),
                    regexp: new TokenType("regexp", startsExpr),
                    string: new TokenType("string", startsExpr),
                    name: new TokenType("name", startsExpr),
                    eof: new TokenType("eof"),
                    bracketL: new TokenType("[", {
                        beforeExpr: true,
                        startsExpr: true
                    }),
                    bracketR: new TokenType("]"),
                    braceL: new TokenType("{", {
                        beforeExpr: true,
                        startsExpr: true
                    }),
                    braceR: new TokenType("}"),
                    parenL: new TokenType("(", {
                        beforeExpr: true,
                        startsExpr: true
                    }),
                    parenR: new TokenType(")"),
                    comma: new TokenType(",", beforeExpr),
                    semi: new TokenType(";", beforeExpr),
                    colon: new TokenType(":", beforeExpr),
                    dot: new TokenType("."),
                    question: new TokenType("?", beforeExpr),
                    arrow: new TokenType("=>", beforeExpr),
                    template: new TokenType("template"),
                    ellipsis: new TokenType("...", beforeExpr),
                    backQuote: new TokenType("`", startsExpr),
                    dollarBraceL: new TokenType("${", {
                        beforeExpr: true,
                        startsExpr: true
                    }),
                    eq: new TokenType("=", {
                        beforeExpr: true,
                        isAssign: true
                    }),
                    assign: new TokenType("_=", {
                        beforeExpr: true,
                        isAssign: true
                    }),
                    incDec: new TokenType("++/--", {
                        prefix: true,
                        postfix: true,
                        startsExpr: true
                    }),
                    prefix: new TokenType("prefix", {
                        beforeExpr: true,
                        prefix: true,
                        startsExpr: true
                    }),
                    logicalOR: binop("||", 1),
                    logicalAND: binop("&&", 2),
                    bitwiseOR: binop("|", 3),
                    bitwiseXOR: binop("^", 4),
                    bitwiseAND: binop("&", 5),
                    equality: binop("==/!=", 6),
                    relational: binop("</>", 7),
                    bitShift: binop("<</>>", 8),
                    plusMin: new TokenType("+/-", {
                        beforeExpr: true,
                        binop: 9,
                        prefix: true,
                        startsExpr: true
                    }),
                    modulo: binop("%", 10),
                    star: binop("*", 10),
                    slash: binop("/", 10),
                    starstar: new TokenType("**", {
                        beforeExpr: true
                    })
                };
                exports.types = types;
                var keywords = {};
                exports.keywords = keywords;
                function kw(name) {
                    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                    options.keyword = name;
                    keywords[name] = types["_" + name] = new TokenType(name, options);
                }
                kw("break");
                kw("case", beforeExpr);
                kw("catch");
                kw("continue");
                kw("debugger");
                kw("default", beforeExpr);
                kw("do", {
                    isLoop: true,
                    beforeExpr: true
                });
                kw("else", beforeExpr);
                kw("finally");
                kw("for", {
                    isLoop: true
                });
                kw("function", startsExpr);
                kw("if");
                kw("return", beforeExpr);
                kw("switch");
                kw("throw", beforeExpr);
                kw("try");
                kw("var");
                kw("const");
                kw("while", {
                    isLoop: true
                });
                kw("with");
                kw("new", {
                    beforeExpr: true,
                    startsExpr: true
                });
                kw("this", startsExpr);
                kw("super", startsExpr);
                kw("class");
                kw("extends", beforeExpr);
                kw("export");
                kw("import");
                kw("null", startsExpr);
                kw("true", startsExpr);
                kw("false", startsExpr);
                kw("in", {
                    beforeExpr: true,
                    binop: 7
                });
                kw("instanceof", {
                    beforeExpr: true,
                    binop: 7
                });
                kw("typeof", {
                    beforeExpr: true,
                    prefix: true,
                    startsExpr: true
                });
                kw("void", {
                    beforeExpr: true,
                    prefix: true,
                    startsExpr: true
                });
                kw("delete", {
                    beforeExpr: true,
                    prefix: true,
                    startsExpr: true
                });
            }, {} ],
            15: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                exports.isArray = isArray;
                exports.has = has;
                function isArray(obj) {
                    return Object.prototype.toString.call(obj) === "[object Array]";
                }
                function has(obj, propName) {
                    return Object.prototype.hasOwnProperty.call(obj, propName);
                }
            }, {} ],
            16: [ function(_dereq_, module, exports) {
                "use strict";
                exports.__esModule = true;
                exports.isNewLine = isNewLine;
                var lineBreak = /\r\n?|\n|\u2028|\u2029/;
                exports.lineBreak = lineBreak;
                var lineBreakG = new RegExp(lineBreak.source, "g");
                exports.lineBreakG = lineBreakG;
                function isNewLine(code) {
                    return code === 10 || code === 13 || code === 8232 || code == 8233;
                }
                var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
                exports.nonASCIIwhitespace = nonASCIIwhitespace;
                var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
                exports.skipWhiteSpace = skipWhiteSpace;
            }, {} ]
        }, {}, [ 3 ])(3);
    }();
    JSParsingTools.parse = acornExports.parse || acornExports.acorn.parse;
    var codeGetExports = {};
    (function(exports) {
        "use strict";
        var isArray, json, renumber, hexadecimal, quotes, escapeless, parentheses, semicolons, safeConcatenation, directive, extra, parse, FORMAT_MINIFY, FORMAT_DEFAULTS;
        var Syntax = {
            AssignmentExpression: "AssignmentExpression",
            ArrayExpression: "ArrayExpression",
            ArrayPattern: "ArrayPattern",
            ArrowFunctionExpression: "ArrowFunctionExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ClassBody: "ClassBody",
            ClassDeclaration: "ClassDeclaration",
            ClassExpression: "ClassExpression",
            ComprehensionBlock: "ComprehensionBlock",
            ComprehensionExpression: "ComprehensionExpression",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DirectiveStatement: "DirectiveStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExportBatchSpecifier: "ExportBatchSpecifier",
            ExportDeclaration: "ExportDeclaration",
            ExportSpecifier: "ExportSpecifier",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForInStatement: "ForInStatement",
            ForOfStatement: "ForOfStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            GeneratorExpression: "GeneratorExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            ImportSpecifier: "ImportSpecifier",
            ImportDeclaration: "ImportDeclaration",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            MethodDefinition: "MethodDefinition",
            ModuleDeclaration: "ModuleDeclaration",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            ObjectPattern: "ObjectPattern",
            Program: "Program",
            Property: "Property",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SpreadElement: "SpreadElement",
            SwitchStatement: "SwitchStatement",
            SwitchCase: "SwitchCase",
            TaggedTemplateExpression: "TaggedTemplateExpression",
            TemplateElement: "TemplateElement",
            TemplateLiteral: "TemplateLiteral",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement",
            YieldExpression: "YieldExpression"
        };
        var Precedence = {
            Sequence: 0,
            Yield: 1,
            Assignment: 1,
            Conditional: 2,
            ArrowFunction: 2,
            LogicalOR: 3,
            LogicalAND: 4,
            BitwiseOR: 5,
            BitwiseXOR: 6,
            BitwiseAND: 7,
            Equality: 8,
            Relational: 9,
            BitwiseSHIFT: 10,
            Additive: 11,
            Multiplicative: 12,
            Unary: 13,
            Postfix: 14,
            Call: 15,
            New: 16,
            TaggedTemplate: 17,
            Member: 18,
            Primary: 19
        };
        var BinaryPrecedence = {
            "||": Precedence.LogicalOR,
            "&&": Precedence.LogicalAND,
            "|": Precedence.BitwiseOR,
            "^": Precedence.BitwiseXOR,
            "&": Precedence.BitwiseAND,
            "==": Precedence.Equality,
            "!=": Precedence.Equality,
            "===": Precedence.Equality,
            "!==": Precedence.Equality,
            is: Precedence.Equality,
            isnt: Precedence.Equality,
            "<": Precedence.Relational,
            ">": Precedence.Relational,
            "<=": Precedence.Relational,
            ">=": Precedence.Relational,
            "in": Precedence.Relational,
            "instanceof": Precedence.Relational,
            "<<": Precedence.BitwiseSHIFT,
            ">>": Precedence.BitwiseSHIFT,
            ">>>": Precedence.BitwiseSHIFT,
            "+": Precedence.Additive,
            "-": Precedence.Additive,
            "*": Precedence.Multiplicative,
            "%": Precedence.Multiplicative,
            "/": Precedence.Multiplicative
        };
        function getDefaultOptions() {
            return {
                indent: null,
                base: null,
                parse: null,
                format: {
                    indent: {
                        style: "    ",
                        base: 0
                    },
                    newline: "\n",
                    space: " ",
                    json: false,
                    renumber: false,
                    hexadecimal: false,
                    quotes: "single",
                    escapeless: false,
                    compact: false,
                    parentheses: true,
                    semicolons: true,
                    safeConcatenation: false
                },
                directive: false,
                raw: true,
                verbatim: null
            };
        }
        var NON_ASCII_WHITESPACES = [ 5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279 ];
        var NON_ASCII_IDENTIFIER_CHARACTERS_REGEXP = new RegExp("[ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮ̀-ʹͶ" + "ͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁ҃-҇Ҋ-" + "ԧԱ-Ֆՙա-և֑-ׇֽֿׁׂׅׄא-ת" + "װ-ײؐ-ؚؠ-٩ٮ-ۓە-ۜ۟-۪ۨ-ۼۿܐ-" + "݊ݍ-ޱ߀-ߵߺࠀ-࠭ࡀ-࡛ࢠࢢ-ࢬࣤ-ࣾऀ-" + "ॣ०-९ॱ-ॷॹ-ॿঁ-ঃঅ-ঌএঐও-নপ-" + "রলশ-হ়-ৄেৈো-ৎৗড়ঢ়য়-ৣ০-" + "ৱਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸ" + "ਹ਼ਾ-ੂੇੈੋ-੍ੑਖ਼-ੜਫ਼੦-ੵઁ-ઃ" + "અ-ઍએ-ઑઓ-નપ-રલળવ-હ઼-ૅે-ૉ" + "ો-્ૐૠ-ૣ૦-૯ଁ-ଃଅ-ଌଏଐଓ-ନପ-" + "ରଲଳଵ-ହ଼-ୄେୈୋ-୍ୖୗଡ଼ଢ଼ୟ-" + "ୣ୦-୯ୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞ" + "டணதந-பம-ஹா-ூெ-ைொ-்ௐௗ௦-" + "௯ఁ-ఃఅ-ఌఎ-ఐఒ-నప-ళవ-హఽ-ౄె-" + "ైొ-్ౕౖౘౙౠ-ౣ౦-౯ಂಃಅ-ಌಎ-" + "ಐಒ-ನಪ-ಳವ-ಹ಼-ೄೆ-ೈೊ-್ೕೖೞ" + "ೠ-ೣ೦-೯ೱೲംഃഅ-ഌഎ-ഐഒ-ഺഽ-ൄ" + "െ-ൈൊ-ൎൗൠ-ൣ൦-൯ൺ-ൿංඃඅ-ඖක-" + "නඳ-රලව-ෆ්ා-ුූෘ-ෟෲෳก-ฺ" + "เ-๎๐-๙ກຂຄງຈຊຍດ-ທນ-ຟມ-" + "ຣລວສຫອ-ູົ-ຽເ-ໄໆ່-ໍ໐-໙" + "ໜ-ໟༀ༘༙༠-༩༹༵༷༾-ཇཉ-ཬཱ-྄" + "྆-ྗྙ-ྼ࿆က-၉ၐ-ႝႠ-ჅჇჍა-ჺჼ-" + "ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵ" + "ኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፝-፟ᎀ-" + "ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-" + "᜔ᜠ-᜴ᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-៓ៗៜ៝" + "០-៩᠋-᠍᠐-᠙ᠠ-ᡷᢀ-ᢪᢰ-ᣵᤀ-ᤜᤠ-ᤫ" + "ᤰ-᤻᥆-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉ᧐-᧙ᨀ-ᨛᨠ-ᩞ" + "᩠-᩿᩼-᪉᪐-᪙ᪧᬀ-ᭋ᭐-᭙᭫-᭳ᮀ-᯳ᰀ-" + "᰷᱀-᱉ᱍ-ᱽ᳐-᳔᳒-ᳶᴀ-ᷦ᷼-ἕἘ-Ἕἠ-" + "ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-" + "ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼ‌‍‿" + "⁀⁔ⁱⁿₐ-ₜ⃐-⃥⃜⃡-⃰ℂℇℊ-ℓℕ" + "ℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈ" + "Ⰰ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯ⵿-" + "ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-" + "ⷞⷠ-ⷿⸯ々-〇〡-〯〱-〵〸-〼ぁ-ゖ゙゚" + "ゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵" + "一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘫꙀ-꙯ꙴ-꙽ꙿ-ꚗ" + "ꚟ-꛱ꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠧꡀ-ꡳ" + "ꢀ-꣄꣐-꣙꣠-ꣷꣻ꤀-꤭ꤰ-꥓ꥠ-ꥼꦀ-꧀ꧏ-" + "꧙ꨀ-ꨶꩀ-ꩍ꩐-꩙ꩠ-ꩶꩺꩻꪀ-ꫂꫛ-ꫝꫠ-" + "ꫯꫲ-꫶ꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯪ꯬" + "꯭꯰-꯹가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-" + "ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽ" + "ﵐ-ﶏﶒ-ﷇﷰ-ﷻ︀-️︠-︦︳︴﹍-﹏ﹰ-ﹴ" + "ﹶ-ﻼ０-９Ａ-Ｚ＿ａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-" + "ￗￚ-ￜ]");
        function isIdentifierCh(cp) {
            if (cp < 128) {
                return cp >= 97 && cp <= 122 || cp >= 65 && cp <= 90 || cp >= 48 && cp <= 57 || cp === 36 || cp === 95 || cp === 92;
            }
            var ch = String.fromCharCode(cp);
            return NON_ASCII_IDENTIFIER_CHARACTERS_REGEXP.test(ch);
        }
        function isLineTerminator(cp) {
            return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
        }
        function isWhitespace(cp) {
            return cp === 32 || cp === 9 || isLineTerminator(cp) || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && NON_ASCII_WHITESPACES.indexOf(cp) >= 0;
        }
        function isDecimalDigit(cp) {
            return cp >= 48 && cp <= 57;
        }
        function stringRepeat(str, num) {
            var result = "";
            for (num |= 0; num > 0; num >>>= 1, str += str) {
                if (num & 1) {
                    result += str;
                }
            }
            return result;
        }
        isArray = Array.isArray;
        if (!isArray) {
            isArray = function isArray(array) {
                return Object.prototype.toString.call(array) === "[object Array]";
            };
        }
        function updateDeeply(target, override) {
            var key, val;
            function isHashObject(target) {
                return typeof target === "object" && target instanceof Object && !(target instanceof RegExp);
            }
            for (key in override) {
                if (override.hasOwnProperty(key)) {
                    val = override[key];
                    if (isHashObject(val)) {
                        if (isHashObject(target[key])) {
                            updateDeeply(target[key], val);
                        } else {
                            target[key] = updateDeeply({}, val);
                        }
                    } else {
                        target[key] = val;
                    }
                }
            }
            return target;
        }
        function generateNumber(value) {
            var result, point, temp, exponent, pos;
            if (value === 1 / 0) {
                return json ? "null" : renumber ? "1e400" : "1e+400";
            }
            result = "" + value;
            if (!renumber || result.length < 3) {
                return result;
            }
            point = result.indexOf(".");
            if (!json && result.charCodeAt(0) === 48 && point === 1) {
                point = 0;
                result = result.slice(1);
            }
            temp = result;
            result = result.replace("e+", "e");
            exponent = 0;
            if ((pos = temp.indexOf("e")) > 0) {
                exponent = +temp.slice(pos + 1);
                temp = temp.slice(0, pos);
            }
            if (point >= 0) {
                exponent -= temp.length - point - 1;
                temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
            }
            pos = 0;
            while (temp.charCodeAt(temp.length + pos - 1) === 48) {
                --pos;
            }
            if (pos !== 0) {
                exponent -= pos;
                temp = temp.slice(0, pos);
            }
            if (exponent !== 0) {
                temp += "e" + exponent;
            }
            if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length) && +temp === value) {
                result = temp;
            }
            return result;
        }
        function escapeRegExpCharacter(ch, previousIsBackslash) {
            if ((ch & ~1) === 8232) {
                return (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029");
            } else if (ch === 10 || ch === 13) {
                return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
            }
            return String.fromCharCode(ch);
        }
        function generateRegExp(reg) {
            var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
            result = reg.toString();
            if (reg.source) {
                match = result.match(/\/([^\/]*)$/);
                if (!match) {
                    return result;
                }
                flags = match[1];
                result = "";
                characterInBrack = false;
                previousIsBackslash = false;
                for (i = 0, iz = reg.source.length; i < iz; ++i) {
                    ch = reg.source.charCodeAt(i);
                    if (!previousIsBackslash) {
                        if (characterInBrack) {
                            if (ch === 93) {
                                characterInBrack = false;
                            }
                        } else {
                            if (ch === 47) {
                                result += "\\";
                            } else if (ch === 91) {
                                characterInBrack = true;
                            }
                        }
                        result += escapeRegExpCharacter(ch, previousIsBackslash);
                        previousIsBackslash = ch === 92;
                    } else {
                        result += escapeRegExpCharacter(ch, previousIsBackslash);
                        previousIsBackslash = false;
                    }
                }
                return "/" + result + "/" + flags;
            }
            return result;
        }
        function escapeAllowedCharacter(code, next) {
            var hex, result = "\\";
            switch (code) {
              case 8:
                result += "b";
                break;

              case 12:
                result += "f";
                break;

              case 9:
                result += "t";
                break;

              default:
                hex = code.toString(16).toUpperCase();
                if (json || code > 255) {
                    result += "u" + "0000".slice(hex.length) + hex;
                } else if (code === 0 && !isDecimalDigit(next)) {
                    result += "0";
                } else if (code === 11) {
                    result += "x0B";
                } else {
                    result += "x" + "00".slice(hex.length) + hex;
                }
                break;
            }
            return result;
        }
        function escapeDisallowedCharacter(code) {
            var result = "\\";
            switch (code) {
              case 92:
                result += "\\";
                break;

              case 10:
                result += "n";
                break;

              case 13:
                result += "r";
                break;

              case 8232:
                result += "u2028";
                break;

              case 8233:
                result += "u2029";
                break;
            }
            return result;
        }
        function escapeDirective(str) {
            var i, iz, code, quote;
            quote = quotes === "double" ? '"' : "'";
            for (i = 0, iz = str.length; i < iz; ++i) {
                code = str.charCodeAt(i);
                if (code === 39) {
                    quote = '"';
                    break;
                } else if (code === 34) {
                    quote = "'";
                    break;
                } else if (code === 92) {
                    ++i;
                }
            }
            return quote + str + quote;
        }
        function escapeString(str) {
            var result = "", i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
            for (i = 0, len = str.length; i < len; ++i) {
                code = str.charCodeAt(i);
                if (code === 39) {
                    ++singleQuotes;
                } else if (code === 34) {
                    ++doubleQuotes;
                } else if (code === 47 && json) {
                    result += "\\";
                } else if (isLineTerminator(code) || code === 92) {
                    result += escapeDisallowedCharacter(code);
                    continue;
                } else if (json && code < 32 || !(json || escapeless || code >= 32 && code <= 126)) {
                    result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                    continue;
                }
                result += String.fromCharCode(code);
            }
            single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes);
            quote = single ? "'" : '"';
            if (!(single ? singleQuotes : doubleQuotes)) {
                return quote + result + quote;
            }
            str = result;
            result = quote;
            for (i = 0, len = str.length; i < len; ++i) {
                code = str.charCodeAt(i);
                if (code === 39 && single || code === 34 && !single) {
                    result += "\\";
                }
                result += String.fromCharCode(code);
            }
            return result + quote;
        }
        function join(l, r) {
            if (!l.length) return r;
            if (!r.length) return l;
            var lCp = l.charCodeAt(l.length - 1), rCp = r.charCodeAt(0);
            if (isIdentifierCh(lCp) && isIdentifierCh(rCp) || lCp === rCp && (lCp === 43 || lCp === 45) || lCp === 47 && rCp === 105) {
                return l + _.space + r;
            } else if (isWhitespace(lCp) || isWhitespace(rCp)) return l + r;
            return l + _.optSpace + r;
        }
        function shiftIndent() {
            var prevIndent = _.indent;
            _.indent += _.indentUnit;
            return prevIndent;
        }
        function adoptionPrefix($stmt) {
            if ($stmt.type === Syntax.BlockStatement) return _.optSpace;
            if ($stmt.type === Syntax.EmptyStatement) return "";
            return _.newline + _.indent + _.indentUnit;
        }
        function adoptionSuffix($stmt) {
            if ($stmt.type === Syntax.BlockStatement) return _.optSpace;
            return _.newline + _.indent;
        }
        function generateVerbatim($expr, settings) {
            var verbatim = $expr[extra.verbatim], strVerbatim = typeof verbatim === "string", precedence = !strVerbatim && verbatim.precedence !== void 0 ? verbatim.precedence : Precedence.Sequence, parenthesize = precedence < settings.precedence, content = strVerbatim ? verbatim : verbatim.content, chunks = content.split(/\r\n|\n/), chunkCount = chunks.length;
            if (parenthesize) _.js += "(";
            _.js += chunks[0];
            for (var i = 1; i < chunkCount; i++) _.js += _.newline + _.indent + chunks[i];
            if (parenthesize) _.js += ")";
        }
        function generateFunctionParams($node) {
            var $params = $node.params, $rest = $node.rest, $defaults = $node.defaults, paramCount = $params.length, lastParamIdx = paramCount - 1, hasDefaults = !!$defaults, arrowFuncWithSingleParam = $node.type === Syntax.ArrowFunctionExpression && !$rest && (!hasDefaults || $defaults.length === 0) && paramCount === 1 && $params[0].type === Syntax.Identifier;
            if (arrowFuncWithSingleParam) _.js += $params[0].name; else {
                _.js += "(";
                for (var i = 0; i < paramCount; ++i) {
                    var $param = $params[i];
                    if (hasDefaults && $defaults[i]) {
                        var $fakeAssign = {
                            left: $param,
                            right: $defaults[i],
                            operator: "="
                        };
                        ExprGen.AssignmentExpression($fakeAssign, Preset.e4);
                    } else {
                        if ($params[i].type === Syntax.Identifier) _.js += $param.name; else ExprGen[$param.type]($param, Preset.e4);
                    }
                    if (i !== lastParamIdx) _.js += "," + _.optSpace;
                }
                if ($rest) {
                    if (paramCount) _.js += "," + _.optSpace;
                    _.js += "..." + $rest.name;
                }
                _.js += ")";
            }
        }
        function generateFunctionBody($node) {
            var $body = $node.body;
            generateFunctionParams($node);
            if ($node.type === Syntax.ArrowFunctionExpression) _.js += _.optSpace + "=>";
            if ($node.expression) {
                _.js += _.optSpace;
                var exprJs = exprToJs($body, Preset.e4);
                if (exprJs.charAt(0) === "{") exprJs = "(" + exprJs + ")";
                _.js += exprJs;
            } else {
                _.js += adoptionPrefix($body);
                StmtGen[$body.type]($body, Preset.s8);
            }
        }
        var Preset = {
            e1: function(allowIn) {
                return {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn,
                    allowCall: true,
                    allowUnparenthesizedNew: true
                };
            },
            e2: function(allowIn) {
                return {
                    precedence: Precedence.LogicalOR,
                    allowIn: allowIn,
                    allowCall: true,
                    allowUnparenthesizedNew: true
                };
            },
            e3: {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: false
            },
            e4: {
                precedence: Precedence.Assignment,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: true
            },
            e5: {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: true
            },
            e6: function(allowUnparenthesizedNew) {
                return {
                    precedence: Precedence.New,
                    allowIn: true,
                    allowCall: false,
                    allowUnparenthesizedNew: allowUnparenthesizedNew
                };
            },
            e7: {
                precedence: Precedence.Unary,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: true
            },
            e8: {
                precedence: Precedence.Postfix,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: true
            },
            e9: {
                precedence: void 0,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: true
            },
            e10: {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: true
            },
            e11: function(allowCall) {
                return {
                    precedence: Precedence.Call,
                    allowIn: true,
                    allowCall: allowCall,
                    allowUnparenthesizedNew: false
                };
            },
            e12: {
                precedence: Precedence.Primary,
                allowIn: false,
                allowCall: false,
                allowUnparenthesizedNew: true
            },
            e13: {
                precedence: Precedence.Primary,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: true
            },
            e14: {
                precedence: Precedence.Sequence,
                allowIn: false,
                allowCall: true,
                allowUnparenthesizedNew: true
            },
            e15: function(allowCall) {
                return {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: allowCall,
                    allowUnparenthesizedNew: true
                };
            },
            e16: function(precedence, allowIn) {
                return {
                    precedence: precedence,
                    allowIn: allowIn,
                    allowCall: true,
                    allowUnparenthesizedNew: true
                };
            },
            e17: function(allowIn) {
                return {
                    precedence: Precedence.Call,
                    allowIn: allowIn,
                    allowCall: true,
                    allowUnparenthesizedNew: true
                };
            },
            e18: function(allowIn) {
                return {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn,
                    allowCall: true,
                    allowUnparenthesizedNew: true
                };
            },
            e19: {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true,
                semicolonOptional: false
            },
            s1: function(functionBody, semicolonOptional) {
                return {
                    allowIn: true,
                    functionBody: false,
                    directiveContext: functionBody,
                    semicolonOptional: semicolonOptional
                };
            },
            s2: {
                allowIn: true,
                functionBody: false,
                directiveContext: false,
                semicolonOptional: true
            },
            s3: function(allowIn) {
                return {
                    allowIn: allowIn,
                    functionBody: false,
                    directiveContext: false,
                    semicolonOptional: false
                };
            },
            s4: function(semicolonOptional) {
                return {
                    allowIn: true,
                    functionBody: false,
                    directiveContext: false,
                    semicolonOptional: semicolonOptional
                };
            },
            s5: function(semicolonOptional) {
                return {
                    allowIn: true,
                    functionBody: false,
                    directiveContext: true,
                    semicolonOptional: semicolonOptional
                };
            },
            s6: {
                allowIn: false,
                functionBody: false,
                directiveContext: false,
                semicolonOptional: false
            },
            s7: {
                allowIn: true,
                functionBody: false,
                directiveContext: false,
                semicolonOptional: false
            },
            s8: {
                allowIn: true,
                functionBody: true,
                directiveContext: false,
                semicolonOptional: false
            }
        };
        var FLOATING_OR_OCTAL_REGEXP = /[.eExX]|^0[0-9]+/, LAST_DECIMAL_DIGIT_REGEXP = /[0-9]$/;
        function generateLogicalOrBinaryExpression($expr, settings) {
            var op = $expr.operator, precedence = BinaryPrecedence[$expr.operator], parenthesize = precedence < settings.precedence, allowIn = settings.allowIn || parenthesize, operandGenSettings = Preset.e16(precedence, allowIn), exprJs = exprToJs($expr.left, operandGenSettings);
            parenthesize |= op === "in" && !allowIn;
            if (parenthesize) _.js += "(";
            if (exprJs.charCodeAt(exprJs.length - 1) === 47 && isIdentifierCh(op.charCodeAt(0))) exprJs = exprJs + _.space + op; else exprJs = join(exprJs, op);
            operandGenSettings.precedence++;
            var rightJs = exprToJs($expr.right, operandGenSettings);
            if (op === "/" && rightJs.charAt(0) === "/" || op.slice(-1) === "<" && rightJs.slice(0, 3) === "!--") exprJs += _.space + rightJs; else exprJs = join(exprJs, rightJs);
            _.js += exprJs;
            if (parenthesize) _.js += ")";
        }
        function generateArrayPatternOrExpression($expr) {
            var $elems = $expr.elements, elemCount = $elems.length;
            if (elemCount) {
                var lastElemIdx = elemCount - 1, multiline = elemCount > 1, prevIndent = shiftIndent(), itemPrefix = _.newline + _.indent;
                _.js += "[";
                for (var i = 0; i < elemCount; i++) {
                    var $elem = $elems[i];
                    if (multiline) _.js += itemPrefix;
                    if ($elem) ExprGen[$elem.type]($elem, Preset.e4);
                    if (i !== lastElemIdx || !$elem) _.js += ",";
                }
                _.indent = prevIndent;
                if (multiline) _.js += _.newline + _.indent;
                _.js += "]";
            } else _.js += "[]";
        }
        function generateImportOrExportSpecifier($expr) {
            _.js += $expr.id.name;
            if ($expr.name) _.js += _.space + "as" + _.space + $expr.name.name;
        }
        function generateGeneratorOrComprehensionExpression($expr) {
            var $blocks = $expr.blocks, $filter = $expr.filter, isGenerator = $expr.type === Syntax.GeneratorExpression, exprJs = isGenerator ? "(" : "[", bodyJs = exprToJs($expr.body, Preset.e4);
            if ($blocks) {
                var prevIndent = shiftIndent(), blockCount = $blocks.length;
                for (var i = 0; i < blockCount; ++i) {
                    var blockJs = exprToJs($blocks[i], Preset.e5);
                    exprJs = i > 0 ? join(exprJs, blockJs) : exprJs + blockJs;
                }
                _.indent = prevIndent;
            }
            if ($filter) {
                var filterJs = exprToJs($filter, Preset.e5);
                exprJs = join(exprJs, "if" + _.optSpace);
                exprJs = join(exprJs, "(" + filterJs + ")");
            }
            exprJs = join(exprJs, bodyJs);
            exprJs += isGenerator ? ")" : "]";
            _.js += exprJs;
        }
        var ExprRawGen = {
            SequenceExpression: function generateSequenceExpression($expr, settings) {
                var $children = $expr.expressions, childrenCount = $children.length, lastChildIdx = childrenCount - 1, parenthesize = Precedence.Sequence < settings.precedence, exprGenSettings = Preset.e1(settings.allowIn || parenthesize);
                if (parenthesize) _.js += "(";
                for (var i = 0; i < childrenCount; i++) {
                    var $child = $children[i];
                    ExprGen[$child.type]($child, exprGenSettings);
                    if (i !== lastChildIdx) _.js += "," + _.optSpace;
                }
                if (parenthesize) _.js += ")";
            },
            AssignmentExpression: function generateAssignmentExpression($expr, settings) {
                var $left = $expr.left, $right = $expr.right, parenthesize = Precedence.Assignment < settings.precedence, allowIn = settings.allowIn || parenthesize;
                if (parenthesize) _.js += "(";
                ExprGen[$left.type]($left, Preset.e17(allowIn));
                _.js += _.optSpace + $expr.operator + _.optSpace;
                ExprGen[$right.type]($right, Preset.e18(allowIn));
                if (parenthesize) _.js += ")";
            },
            ArrowFunctionExpression: function generateArrowFunctionExpression($expr, settings) {
                var parenthesize = Precedence.ArrowFunction < settings.precedence;
                if (parenthesize) _.js += "(";
                generateFunctionBody($expr);
                if (parenthesize) _.js += ")";
            },
            ConditionalExpression: function generateConditionalExpression($expr, settings) {
                var $test = $expr.test, $conseq = $expr.consequent, $alt = $expr.alternate, parenthesize = Precedence.Conditional < settings.precedence, allowIn = settings.allowIn || parenthesize, testGenSettings = Preset.e2(allowIn), branchGenSettings = Preset.e1(allowIn);
                if (parenthesize) _.js += "(";
                ExprGen[$test.type]($test, testGenSettings);
                _.js += _.optSpace + "?" + _.optSpace;
                ExprGen[$conseq.type]($conseq, branchGenSettings);
                _.js += _.optSpace + ":" + _.optSpace;
                ExprGen[$alt.type]($alt, branchGenSettings);
                if (parenthesize) _.js += ")";
            },
            LogicalExpression: generateLogicalOrBinaryExpression,
            BinaryExpression: generateLogicalOrBinaryExpression,
            CallExpression: function generateCallExpression($expr, settings) {
                var $callee = $expr.callee, $args = $expr["arguments"], argCount = $args.length, lastArgIdx = argCount - 1, parenthesize = !settings.allowCall || Precedence.Call < settings.precedence;
                if (parenthesize) _.js += "(";
                ExprGen[$callee.type]($callee, Preset.e3);
                _.js += "(";
                for (var i = 0; i < argCount; ++i) {
                    var $arg = $args[i];
                    ExprGen[$arg.type]($arg, Preset.e4);
                    if (i !== lastArgIdx) _.js += "," + _.optSpace;
                }
                _.js += ")";
                if (parenthesize) _.js += ")";
            },
            NewExpression: function generateNewExpression($expr, settings) {
                var $args = $expr["arguments"], parenthesize = Precedence.New < settings.precedence, argCount = $args.length, lastArgIdx = argCount - 1, withCall = !settings.allowUnparenthesizedNew || parentheses || argCount > 0, calleeJs = exprToJs($expr.callee, Preset.e6(!withCall));
                if (parenthesize) _.js += "(";
                _.js += join("new", calleeJs);
                if (withCall) {
                    _.js += "(";
                    for (var i = 0; i < argCount; ++i) {
                        var $arg = $args[i];
                        ExprGen[$arg.type]($arg, Preset.e4);
                        if (i !== lastArgIdx) _.js += "," + _.optSpace;
                    }
                    _.js += ")";
                }
                if (parenthesize) _.js += ")";
            },
            MemberExpression: function generateMemberExpression($expr, settings) {
                var $obj = $expr.object, $prop = $expr.property, parenthesize = Precedence.Member < settings.precedence, isNumObj = !$expr.computed && $obj.type === Syntax.Literal && typeof $obj.value === "number";
                if (parenthesize) _.js += "(";
                if (isNumObj) {
                    var numJs = exprToJs($obj, Preset.e11(settings.allowCall)), withPoint = LAST_DECIMAL_DIGIT_REGEXP.test(numJs) && !FLOATING_OR_OCTAL_REGEXP.test(numJs);
                    _.js += withPoint ? numJs + "." : numJs;
                } else ExprGen[$obj.type]($obj, Preset.e11(settings.allowCall));
                if ($expr.computed) {
                    _.js += "[";
                    ExprGen[$prop.type]($prop, Preset.e15(settings.allowCall));
                    _.js += "]";
                } else _.js += "." + $prop.name;
                if (parenthesize) _.js += ")";
            },
            UnaryExpression: function generateUnaryExpression($expr, settings) {
                var parenthesize = Precedence.Unary < settings.precedence, op = $expr.operator, argJs = exprToJs($expr.argument, Preset.e7);
                if (parenthesize) _.js += "(";
                if (_.optSpace === "" || op.length > 2) _.js += join(op, argJs); else {
                    _.js += op;
                    var leftCp = op.charCodeAt(op.length - 1), rightCp = argJs.charCodeAt(0);
                    if (leftCp === rightCp && (leftCp === 43 || leftCp === 45) || isIdentifierCh(leftCp) && isIdentifierCh(rightCp)) {
                        _.js += _.space;
                    }
                    _.js += argJs;
                }
                if (parenthesize) _.js += ")";
            },
            YieldExpression: function generateYieldExpression($expr, settings) {
                var $arg = $expr.argument, js = $expr.delegate ? "yield*" : "yield", parenthesize = Precedence.Yield < settings.precedence;
                if (parenthesize) _.js += "(";
                if ($arg) {
                    var argJs = exprToJs($arg, Preset.e4);
                    js = join(js, argJs);
                }
                _.js += js;
                if (parenthesize) _.js += ")";
            },
            UpdateExpression: function generateUpdateExpression($expr, settings) {
                var $arg = $expr.argument, $op = $expr.operator, prefix = $expr.prefix, precedence = prefix ? Precedence.Unary : Precedence.Postfix, parenthesize = precedence < settings.precedence;
                if (parenthesize) _.js += "(";
                if (prefix) {
                    _.js += $op;
                    ExprGen[$arg.type]($arg, Preset.e8);
                } else {
                    ExprGen[$arg.type]($arg, Preset.e8);
                    _.js += $op;
                }
                if (parenthesize) _.js += ")";
            },
            FunctionExpression: function generateFunctionExpression($expr) {
                var isGenerator = !!$expr.generator;
                _.js += isGenerator ? "function*" : "function";
                if ($expr.id) {
                    _.js += isGenerator ? _.optSpace : _.space;
                    _.js += $expr.id.name;
                } else _.js += _.optSpace;
                generateFunctionBody($expr);
            },
            ExportBatchSpecifier: function generateExportBatchSpecifier() {
                _.js += "*";
            },
            ArrayPattern: generateArrayPatternOrExpression,
            ArrayExpression: generateArrayPatternOrExpression,
            ClassExpression: function generateClassExpression($expr) {
                var $id = $expr.id, $super = $expr.superClass, $body = $expr.body, exprJs = "class";
                if ($id) {
                    var idJs = exprToJs($id, Preset.e9);
                    exprJs = join(exprJs, idJs);
                }
                if ($super) {
                    var superJs = exprToJs($super, Preset.e4);
                    superJs = join("extends", superJs);
                    exprJs = join(exprJs, superJs);
                }
                _.js += exprJs + _.optSpace;
                StmtGen[$body.type]($body, Preset.s2);
            },
            MethodDefinition: function generateMethodDefinition($expr) {
                var exprJs = $expr["static"] ? "static" + _.optSpace : "", keyJs = exprToJs($expr.key, Preset.e5);
                if ($expr.computed) keyJs = "[" + keyJs + "]";
                if ($expr.kind === "get" || $expr.kind === "set") {
                    keyJs = join($expr.kind, keyJs);
                    _.js += join(exprJs, keyJs);
                } else {
                    if ($expr.value.generator) _.js += exprJs + "*" + keyJs; else _.js += join(exprJs, keyJs);
                }
                generateFunctionBody($expr.value);
            },
            Property: function generateProperty($expr) {
                var $val = $expr.value, $kind = $expr.kind, keyJs = exprToJs($expr.key, Preset.e5);
                if ($expr.computed) keyJs = "[" + keyJs + "]";
                if ($kind === "get" || $kind === "set") {
                    _.js += $kind + _.space + keyJs;
                    generateFunctionBody($val);
                } else {
                    if ($expr.shorthand) _.js += keyJs; else if ($expr.method) {
                        _.js += $val.generator ? "*" + keyJs : keyJs;
                        generateFunctionBody($val);
                    } else {
                        _.js += keyJs + ":" + _.optSpace;
                        ExprGen[$val.type]($val, Preset.e4);
                    }
                }
            },
            ObjectExpression: function generateObjectExpression($expr) {
                var $props = $expr.properties, propCount = $props.length;
                if (propCount) {
                    var lastPropIdx = propCount - 1, prevIndent = shiftIndent();
                    _.js += "{";
                    for (var i = 0; i < propCount; i++) {
                        var $prop = $props[i], propType = $prop.type || Syntax.Property;
                        _.js += _.newline + _.indent;
                        ExprGen[propType]($prop, Preset.e5);
                        if (i !== lastPropIdx) _.js += ",";
                    }
                    _.indent = prevIndent;
                    _.js += _.newline + _.indent + "}";
                } else _.js += "{}";
            },
            ObjectPattern: function generateObjectPattern($expr) {
                var $props = $expr.properties, propCount = $props.length;
                if (propCount) {
                    var lastPropIdx = propCount - 1, multiline = false;
                    if (propCount === 1) multiline = $props[0].value.type !== Syntax.Identifier; else {
                        for (var i = 0; i < propCount; i++) {
                            if (!$props[i].shorthand) {
                                multiline = true;
                                break;
                            }
                        }
                    }
                    _.js += multiline ? "{" + _.newline : "{";
                    var prevIndent = shiftIndent(), propSuffix = "," + (multiline ? _.newline : _.optSpace);
                    for (var i = 0; i < propCount; i++) {
                        var $prop = $props[i];
                        if (multiline) _.js += _.indent;
                        ExprGen[$prop.type]($prop, Preset.e5);
                        if (i !== lastPropIdx) _.js += propSuffix;
                    }
                    _.indent = prevIndent;
                    _.js += multiline ? _.newline + _.indent + "}" : "}";
                } else _.js += "{}";
            },
            ThisExpression: function generateThisExpression() {
                _.js += "this";
            },
            Identifier: function generateIdentifier($expr) {
                _.js += $expr.name;
            },
            ImportSpecifier: generateImportOrExportSpecifier,
            ExportSpecifier: generateImportOrExportSpecifier,
            Literal: function generateLiteral($expr) {
                if (extra.raw && $expr.raw !== void 0) _.js += $expr.raw; else if ($expr.value === null) _.js += "null"; else {
                    var valueType = typeof $expr.value;
                    if (valueType === "string") _.js += escapeString($expr.value); else if (valueType === "number") _.js += generateNumber($expr.value); else if (valueType === "boolean") _.js += $expr.value ? "true" : "false"; else _.js += generateRegExp($expr.value);
                }
            },
            GeneratorExpression: generateGeneratorOrComprehensionExpression,
            ComprehensionExpression: generateGeneratorOrComprehensionExpression,
            ComprehensionBlock: function generateComprehensionBlock($expr) {
                var $left = $expr.left, leftJs = void 0, rightJs = exprToJs($expr.right, Preset.e5);
                if ($left.type === Syntax.VariableDeclaration) leftJs = $left.kind + _.space + stmtToJs($left.declarations[0], Preset.s6); else leftJs = exprToJs($left, Preset.e10);
                leftJs = join(leftJs, $expr.of ? "of" : "in");
                _.js += "for" + _.optSpace + "(" + join(leftJs, rightJs) + ")";
            },
            SpreadElement: function generateSpreadElement($expr) {
                var $arg = $expr.argument;
                _.js += "...";
                ExprGen[$arg.type]($arg, Preset.e4);
            },
            TaggedTemplateExpression: function generateTaggedTemplateExpression($expr, settings) {
                var $tag = $expr.tag, $quasi = $expr.quasi, parenthesize = Precedence.TaggedTemplate < settings.precedence;
                if (parenthesize) _.js += "(";
                ExprGen[$tag.type]($tag, Preset.e11(settings.allowCall));
                ExprGen[$quasi.type]($quasi, Preset.e12);
                if (parenthesize) _.js += ")";
            },
            TemplateElement: function generateTemplateElement($expr) {
                _.js += $expr.value.raw;
            },
            TemplateLiteral: function generateTemplateLiteral($expr) {
                var $quasis = $expr.quasis, $childExprs = $expr.expressions, quasiCount = $quasis.length, lastQuasiIdx = quasiCount - 1;
                _.js += "`";
                for (var i = 0; i < quasiCount; ++i) {
                    var $quasi = $quasis[i];
                    ExprGen[$quasi.type]($quasi, Preset.e13);
                    if (i !== lastQuasiIdx) {
                        var $childExpr = $childExprs[i];
                        _.js += "${" + _.optSpace;
                        ExprGen[$childExpr.type]($childExpr, Preset.e5);
                        _.js += _.optSpace + "}";
                    }
                }
                _.js += "`";
            }
        };
        var EXPR_STMT_UNALLOWED_EXPR_REGEXP = /^{|^class(?:\s|{)|^function(?:\s|\*|\()/;
        function generateTryStatementHandlers(stmtJs, $finalizer, handlers) {
            var handlerCount = handlers.length, lastHandlerIdx = handlerCount - 1;
            for (var i = 0; i < handlerCount; ++i) {
                var handlerJs = stmtToJs(handlers[i], Preset.s7);
                stmtJs = join(stmtJs, handlerJs);
                if ($finalizer || i !== lastHandlerIdx) stmtJs += adoptionSuffix(handlers[i].body);
            }
            return stmtJs;
        }
        function generateForStatementIterator($op, $stmt, settings) {
            var $body = $stmt.body, $left = $stmt.left, bodySemicolonOptional = !semicolons && settings.semicolonOptional, prevIndent1 = shiftIndent(), stmtJs = "for" + _.optSpace + "(";
            if ($left.type === Syntax.VariableDeclaration) {
                var prevIndent2 = shiftIndent();
                stmtJs += $left.kind + _.space + stmtToJs($left.declarations[0], Preset.s6);
                _.indent = prevIndent2;
            } else stmtJs += exprToJs($left, Preset.e10);
            stmtJs = join(stmtJs, $op);
            var rightJs = exprToJs($stmt.right, Preset.e5);
            stmtJs = join(stmtJs, rightJs) + ")";
            _.indent = prevIndent1;
            _.js += stmtJs + adoptionPrefix($body);
            StmtGen[$body.type]($body, Preset.s4(bodySemicolonOptional));
        }
        var StmtRawGen = {
            BlockStatement: function generateBlockStatement($stmt, settings) {
                var $body = $stmt.body, len = $body.length, lastIdx = len - 1, prevIndent = shiftIndent();
                _.js += "{" + _.newline;
                if (settings.functionBody && !$body.length) _.js += "/**/";
                for (var i = 0; i < len; i++) {
                    var $item = $body[i];
                    _.js += _.indent;
                    StmtGen[$item.type]($item, Preset.s1(settings.functionBody, i === lastIdx));
                    _.js += _.newline;
                }
                _.indent = prevIndent;
                _.js += _.indent + "}";
            },
            BreakStatement: function generateBreakStatement($stmt, settings) {
                if ($stmt.label) _.js += "break " + $stmt.label.name; else _.js += "break";
                if (semicolons || !settings.semicolonOptional) _.js += ";";
            },
            ContinueStatement: function generateContinueStatement($stmt, settings) {
                if ($stmt.label) _.js += "continue " + $stmt.label.name; else _.js += "continue";
                if (semicolons || !settings.semicolonOptional) _.js += ";";
            },
            ClassBody: function generateClassBody($stmt) {
                var $body = $stmt.body, itemCount = $body.length, lastItemIdx = itemCount - 1, prevIndent = shiftIndent();
                _.js += "{" + _.newline;
                for (var i = 0; i < itemCount; i++) {
                    var $item = $body[i], itemType = $item.type || Syntax.Property;
                    _.js += _.indent;
                    ExprGen[itemType]($item, Preset.e5);
                    if (i !== lastItemIdx) _.js += _.newline;
                }
                _.indent = prevIndent;
                _.js += _.newline + _.indent + "}";
            },
            ClassDeclaration: function generateClassDeclaration($stmt) {
                var $body = $stmt.body, $super = $stmt.superClass, js = "class " + $stmt.id.name;
                if ($super) {
                    var superJs = exprToJs($super, Preset.e4);
                    js += _.space + join("extends", superJs);
                }
                _.js += js + _.optSpace;
                StmtGen[$body.type]($body, Preset.s2);
            },
            DirectiveStatement: function generateDirectiveStatement($stmt, settings) {
                if (extra.raw && $stmt.raw) _.js += $stmt.raw; else _.js += escapeDirective($stmt.directive);
                if (semicolons || !settings.semicolonOptional) _.js += ";";
            },
            DoWhileStatement: function generateDoWhileStatement($stmt, settings) {
                var $body = $stmt.body, $test = $stmt.test, bodyJs = adoptionPrefix($body) + stmtToJs($body, Preset.s7) + adoptionSuffix($body);
                var stmtJs = join("do", bodyJs);
                _.js += join(stmtJs, "while" + _.optSpace + "(");
                ExprGen[$test.type]($test, Preset.e5);
                _.js += ")";
                if (semicolons || !settings.semicolonOptional) _.js += ";";
            },
            CatchClause: function generateCatchClause($stmt) {
                var $param = $stmt.param, $guard = $stmt.guard, $body = $stmt.body, prevIndent = shiftIndent();
                _.js += "catch" + _.optSpace + "(";
                ExprGen[$param.type]($param, Preset.e5);
                if ($guard) {
                    _.js += " if ";
                    ExprGen[$guard.type]($guard, Preset.e5);
                }
                _.indent = prevIndent;
                _.js += ")" + adoptionPrefix($body);
                StmtGen[$body.type]($body, Preset.s7);
            },
            DebuggerStatement: function generateDebuggerStatement($stmt, settings) {
                _.js += "debugger";
                if (semicolons || !settings.semicolonOptional) _.js += ";";
            },
            EmptyStatement: function generateEmptyStatement() {
                _.js += ";";
            },
            ExportDeclaration: function generateExportDeclaration($stmt, settings) {
                var $specs = $stmt.specifiers, $decl = $stmt.declaration, withSemicolon = semicolons || !settings.semicolonOptional;
                if ($stmt["default"]) {
                    var declJs = exprToJs($decl, Preset.e4);
                    _.js += join("export default", declJs);
                    if (withSemicolon) _.js += ";";
                } else if ($specs) {
                    var stmtJs = "export";
                    if ($specs.length === 0) stmtJs += _.optSpace + "{" + _.optSpace + "}"; else if ($specs[0].type === Syntax.ExportBatchSpecifier) {
                        var specJs = exprToJs($specs[0], Preset.e5);
                        stmtJs = join(stmtJs, specJs);
                    } else {
                        var prevIndent = shiftIndent(), specCount = $specs.length, lastSpecIdx = specCount - 1;
                        stmtJs += _.optSpace + "{";
                        for (var i = 0; i < specCount; ++i) {
                            stmtJs += _.newline + _.indent;
                            stmtJs += exprToJs($specs[i], Preset.e5);
                            if (i !== lastSpecIdx) stmtJs += ",";
                        }
                        _.indent = prevIndent;
                        stmtJs += _.newline + _.indent + "}";
                    }
                    if ($stmt.source) {
                        _.js += join(stmtJs, "from" + _.optSpace);
                        ExprGen.Literal($stmt.source);
                    } else _.js += stmtJs;
                    if (withSemicolon) _.js += ";";
                } else if ($decl) {
                    var declJs = stmtToJs($decl, Preset.s4(!withSemicolon));
                    _.js += join("export", declJs);
                }
            },
            ExpressionStatement: function generateExpressionStatement($stmt, settings) {
                var exprJs = exprToJs($stmt.expression, Preset.e5), parenthesize = EXPR_STMT_UNALLOWED_EXPR_REGEXP.test(exprJs) || directive && settings.directiveContext && $stmt.expression.type === Syntax.Literal && typeof $stmt.expression.value === "string";
                if (parenthesize) _.js += "(" + exprJs + ")"; else _.js += exprJs;
                if (semicolons || !settings.semicolonOptional) _.js += ";";
            },
            ImportDeclaration: function generateImportDeclaration($stmt, settings) {
                var $specs = $stmt.specifiers, stmtJs = "import", specCount = $specs.length;
                if (specCount) {
                    var hasBinding = !!$specs[0]["default"], firstNamedIdx = hasBinding ? 1 : 0, lastSpecIdx = specCount - 1;
                    if (hasBinding) stmtJs = join(stmtJs, $specs[0].id.name);
                    if (firstNamedIdx < specCount) {
                        if (hasBinding) stmtJs += ",";
                        stmtJs += _.optSpace + "{";
                        if (firstNamedIdx === lastSpecIdx) stmtJs += _.optSpace + exprToJs($specs[firstNamedIdx], Preset.e5) + _.optSpace; else {
                            var prevIndent = shiftIndent();
                            for (var i = firstNamedIdx; i < specCount; i++) {
                                stmtJs += _.newline + _.indent + exprToJs($specs[i], Preset.e5);
                                if (i !== lastSpecIdx) stmtJs += ",";
                            }
                            _.indent = prevIndent;
                            stmtJs += _.newline + _.indent;
                        }
                        stmtJs += "}" + _.optSpace;
                    }
                    stmtJs = join(stmtJs, "from");
                }
                _.js += stmtJs + _.optSpace;
                ExprGen.Literal($stmt.source);
                if (semicolons || !settings.semicolonOptional) _.js += ";";
            },
            VariableDeclarator: function generateVariableDeclarator($stmt, settings) {
                var $id = $stmt.id, $init = $stmt.init, genSettings = Preset.e1(settings.allowIn);
                if ($init) {
                    ExprGen[$id.type]($id, genSettings);
                    _.js += _.optSpace + "=" + _.optSpace;
                    ExprGen[$init.type]($init, genSettings);
                } else {
                    if ($id.type === Syntax.Identifier) _.js += $id.name; else ExprGen[$id.type]($id, genSettings);
                }
            },
            VariableDeclaration: function generateVariableDeclaration($stmt, settings) {
                var $decls = $stmt.declarations, len = $decls.length, prevIndent = len > 1 ? shiftIndent() : _.indent, declGenSettings = Preset.s3(settings.allowIn);
                _.js += $stmt.kind;
                for (var i = 0; i < len; i++) {
                    var $decl = $decls[i];
                    _.js += i === 0 ? _.space : "," + _.optSpace;
                    StmtGen[$decl.type]($decl, declGenSettings);
                }
                if (semicolons || !settings.semicolonOptional) _.js += ";";
                _.indent = prevIndent;
            },
            ThrowStatement: function generateThrowStatement($stmt, settings) {
                var argJs = exprToJs($stmt.argument, Preset.e5);
                _.js += join("throw", argJs);
                if (semicolons || !settings.semicolonOptional) _.js += ";";
            },
            TryStatement: function generateTryStatement($stmt) {
                var $block = $stmt.block, $finalizer = $stmt.finalizer, stmtJs = "try" + adoptionPrefix($block) + stmtToJs($block, Preset.s7) + adoptionSuffix($block);
                var $handlers = $stmt.handlers || $stmt.guardedHandlers;
                if ($handlers) stmtJs = generateTryStatementHandlers(stmtJs, $finalizer, $handlers);
                if ($stmt.handler) {
                    $handlers = isArray($stmt.handler) ? $stmt.handler : [ $stmt.handler ];
                    stmtJs = generateTryStatementHandlers(stmtJs, $finalizer, $handlers);
                }
                if ($finalizer) {
                    stmtJs = join(stmtJs, "finally" + adoptionPrefix($finalizer));
                    stmtJs += stmtToJs($finalizer, Preset.s7);
                }
                _.js += stmtJs;
            },
            SwitchStatement: function generateSwitchStatement($stmt) {
                var $cases = $stmt.cases, $discr = $stmt.discriminant, prevIndent = shiftIndent();
                _.js += "switch" + _.optSpace + "(";
                ExprGen[$discr.type]($discr, Preset.e5);
                _.js += ")" + _.optSpace + "{" + _.newline;
                _.indent = prevIndent;
                if ($cases) {
                    var caseCount = $cases.length, lastCaseIdx = caseCount - 1;
                    for (var i = 0; i < caseCount; i++) {
                        var $case = $cases[i];
                        _.js += _.indent;
                        StmtGen[$case.type]($case, Preset.s4(i === lastCaseIdx));
                        _.js += _.newline;
                    }
                }
                _.js += _.indent + "}";
            },
            SwitchCase: function generateSwitchCase($stmt, settings) {
                var $conseqs = $stmt.consequent, $firstConseq = $conseqs[0], $test = $stmt.test, i = 0, conseqSemicolonOptional = !semicolons && settings.semicolonOptional, conseqCount = $conseqs.length, lastConseqIdx = conseqCount - 1, prevIndent = shiftIndent();
                if ($test) {
                    var testJs = exprToJs($test, Preset.e5);
                    _.js += join("case", testJs) + ":";
                } else _.js += "default:";
                if (conseqCount && $firstConseq.type === Syntax.BlockStatement) {
                    i++;
                    _.js += adoptionPrefix($firstConseq);
                    StmtGen[$firstConseq.type]($firstConseq, Preset.s7);
                }
                for (;i < conseqCount; i++) {
                    var $conseq = $conseqs[i], semicolonOptional = i === lastConseqIdx && conseqSemicolonOptional;
                    _.js += _.newline + _.indent;
                    StmtGen[$conseq.type]($conseq, Preset.s4(semicolonOptional));
                }
                _.indent = prevIndent;
            },
            IfStatement: function generateIfStatement($stmt, settings) {
                var $conseq = $stmt.consequent, $test = $stmt.test, prevIndent = shiftIndent(), semicolonOptional = !semicolons && settings.semicolonOptional;
                _.js += "if" + _.optSpace + "(";
                ExprGen[$test.type]($test, Preset.e5);
                _.js += ")";
                _.indent = prevIndent;
                _.js += adoptionPrefix($conseq);
                if ($stmt.alternate) {
                    var conseq = stmtToJs($conseq, Preset.s7) + adoptionSuffix($conseq), alt = stmtToJs($stmt.alternate, Preset.s4(semicolonOptional));
                    if ($stmt.alternate.type === Syntax.IfStatement) alt = "else " + alt; else alt = join("else", adoptionPrefix($stmt.alternate) + alt);
                    _.js += join(conseq, alt);
                } else StmtGen[$conseq.type]($conseq, Preset.s4(semicolonOptional));
            },
            ForStatement: function generateForStatement($stmt, settings) {
                var $init = $stmt.init, $test = $stmt.test, $body = $stmt.body, $update = $stmt.update, bodySemicolonOptional = !semicolons && settings.semicolonOptional, prevIndent = shiftIndent();
                _.js += "for" + _.optSpace + "(";
                if ($init) {
                    if ($init.type === Syntax.VariableDeclaration) StmtGen[$init.type]($init, Preset.s6); else {
                        ExprGen[$init.type]($init, Preset.e14);
                        _.js += ";";
                    }
                } else _.js += ";";
                if ($test) {
                    _.js += _.optSpace;
                    ExprGen[$test.type]($test, Preset.e5);
                }
                _.js += ";";
                if ($update) {
                    _.js += _.optSpace;
                    ExprGen[$update.type]($update, Preset.e5);
                }
                _.js += ")";
                _.indent = prevIndent;
                _.js += adoptionPrefix($body);
                StmtGen[$body.type]($body, Preset.s4(bodySemicolonOptional));
            },
            ForInStatement: function generateForInStatement($stmt, settings) {
                generateForStatementIterator("in", $stmt, settings);
            },
            ForOfStatement: function generateForOfStatement($stmt, settings) {
                generateForStatementIterator("of", $stmt, settings);
            },
            LabeledStatement: function generateLabeledStatement($stmt, settings) {
                var $body = $stmt.body, bodySemicolonOptional = !semicolons && settings.semicolonOptional, prevIndent = _.indent;
                _.js += $stmt.label.name + ":" + adoptionPrefix($body);
                if ($body.type !== Syntax.BlockStatement) prevIndent = shiftIndent();
                StmtGen[$body.type]($body, Preset.s4(bodySemicolonOptional));
                _.indent = prevIndent;
            },
            ModuleDeclaration: function generateModuleDeclaration($stmt, settings) {
                _.js += "module" + _.space + $stmt.id.name + _.space + "from" + _.optSpace;
                ExprGen.Literal($stmt.source);
                if (semicolons || !settings.semicolonOptional) _.js += ";";
            },
            Program: function generateProgram($stmt) {
                var $body = $stmt.body, len = $body.length, lastIdx = len - 1;
                if (safeConcatenation && len > 0) _.js += "\n";
                for (var i = 0; i < len; i++) {
                    var $item = $body[i];
                    _.js += _.indent;
                    StmtGen[$item.type]($item, Preset.s5(!safeConcatenation && i === lastIdx));
                    if (i !== lastIdx) _.js += _.newline;
                }
            },
            FunctionDeclaration: function generateFunctionDeclaration($stmt) {
                var isGenerator = !!$stmt.generator;
                _.js += isGenerator ? "function*" + _.optSpace : "function" + _.space;
                _.js += $stmt.id.name;
                generateFunctionBody($stmt);
            },
            ReturnStatement: function generateReturnStatement($stmt, settings) {
                var $arg = $stmt.argument;
                if ($arg) {
                    var argJs = exprToJs($arg, Preset.e5);
                    _.js += join("return", argJs);
                } else _.js += "return";
                if (semicolons || !settings.semicolonOptional) _.js += ";";
            },
            WhileStatement: function generateWhileStatement($stmt, settings) {
                var $body = $stmt.body, $test = $stmt.test, bodySemicolonOptional = !semicolons && settings.semicolonOptional, prevIndent = shiftIndent();
                _.js += "while" + _.optSpace + "(";
                ExprGen[$test.type]($test, Preset.e5);
                _.js += ")";
                _.indent = prevIndent;
                _.js += adoptionPrefix($body);
                StmtGen[$body.type]($body, Preset.s4(bodySemicolonOptional));
            },
            WithStatement: function generateWithStatement($stmt, settings) {
                var $body = $stmt.body, $obj = $stmt.object, bodySemicolonOptional = !semicolons && settings.semicolonOptional, prevIndent = shiftIndent();
                _.js += "with" + _.optSpace + "(";
                ExprGen[$obj.type]($obj, Preset.e5);
                _.js += ")";
                _.indent = prevIndent;
                _.js += adoptionPrefix($body);
                StmtGen[$body.type]($body, Preset.s4(bodySemicolonOptional));
            }
        };
        function generateStatement($stmt, option) {
            StmtGen[$stmt.type]($stmt, option);
        }
        function exprToJs($expr, settings) {
            var savedJs = _.js;
            _.js = "";
            ExprGen[$expr.type]($expr, settings);
            var src = _.js;
            _.js = savedJs;
            return src;
        }
        function stmtToJs($stmt, settings) {
            var savedJs = _.js;
            _.js = "";
            StmtGen[$stmt.type]($stmt, settings);
            var src = _.js;
            _.js = savedJs;
            return src;
        }
        function run($node) {
            _.js = "";
            if (StmtGen[$node.type]) StmtGen[$node.type]($node, Preset.s7); else ExprGen[$node.type]($node, Preset.e19);
            return _.js;
        }
        function wrapExprGen(gen) {
            return function($expr, settings) {
                if (extra.verbatim && $expr.hasOwnProperty(extra.verbatim)) generateVerbatim($expr, settings); else gen($expr, settings);
            };
        }
        function createExprGenWithExtras() {
            var gens = {};
            for (var key in ExprRawGen) {
                if (ExprRawGen.hasOwnProperty(key)) gens[key] = wrapExprGen(ExprRawGen[key]);
            }
            return gens;
        }
        var _ = {
            js: "",
            newline: "\n",
            optSpace: " ",
            space: " ",
            indentUnit: "    ",
            indent: ""
        };
        var ExprGen = void 0, StmtGen = StmtRawGen;
        function generate($node, options) {
            var defaultOptions = getDefaultOptions(), result, pair;
            if (options != null) {
                if (typeof options.indent === "string") {
                    defaultOptions.format.indent.style = options.indent;
                }
                if (typeof options.base === "number") {
                    defaultOptions.format.indent.base = options.base;
                }
                options = updateDeeply(defaultOptions, options);
                _.indentUnit = options.format.indent.style;
                if (typeof options.base === "string") {
                    _.indent = options.base;
                } else {
                    _.indent = stringRepeat(_.indentUnit, options.format.indent.base);
                }
            } else {
                options = defaultOptions;
                _.indentUnit = options.format.indent.style;
                _.indent = stringRepeat(_.indentUnit, options.format.indent.base);
            }
            json = options.format.json;
            renumber = options.format.renumber;
            hexadecimal = json ? false : options.format.hexadecimal;
            quotes = json ? "double" : options.format.quotes;
            escapeless = options.format.escapeless;
            _.newline = options.format.newline;
            _.optSpace = options.format.space;
            if (options.format.compact) _.newline = _.optSpace = _.indentUnit = _.indent = "";
            _.space = _.optSpace ? _.optSpace : " ";
            parentheses = options.format.parentheses;
            semicolons = options.format.semicolons;
            safeConcatenation = options.format.safeConcatenation;
            directive = options.directive;
            parse = json ? null : options.parse;
            extra = options;
            if (extra.verbatim) ExprGen = createExprGenWithExtras(); else ExprGen = ExprRawGen;
            return run($node);
        }
        FORMAT_MINIFY = {
            indent: {
                style: "",
                base: 0
            },
            renumber: true,
            hexadecimal: true,
            quotes: "auto",
            escapeless: true,
            compact: true,
            parentheses: false,
            semicolons: false
        };
        FORMAT_DEFAULTS = getDefaultOptions().format;
        exports.generate = generate;
        exports.Precedence = updateDeeply({}, Precedence);
        exports.browser = false;
        exports.FORMAT_MINIFY = FORMAT_MINIFY;
        exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
    })(codeGetExports);
    JSParsingTools.generate = codeGetExports.generate;
    if (typeof module !== "undefined" && module.exports) module.exports = JSParsingTools; else {
        HammerheadClient.define("Shared.JSParsingTools", function() {
            this.exports = JSParsingTools;
        });
    }
})();